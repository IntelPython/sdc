# *****************************************************************************
# Copyright (c) 2019, Intel Corporation All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#     Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# *****************************************************************************

"""

| :class:`pandas.core.strings.StringMethods` functions and operators implementations in HPAT

    .. only:: developer

    This is autogenerated sources for all Unicode string functions supported by Numba.
    Currently tested 45 functions only. List of functions obtained automatically from
    `numba.types.misc.UnicodeType` class

    Example of the generated method (for method upper()):
    `hpat_pandas_stringmethods_upper_parallel_impl` is paralell version
    (required additional import mentioned in the body)

    @overload_method(StringMethodsType, 'upper')
    def hpat_pandas_stringmethods_upper(self):

        ty_checker = TypeChecker('Method stringmethods.upper().')
        ty_checker.check(self, StringMethodsType)

        def hpat_pandas_stringmethods_upper_parallel_impl(self):
            from numba.parfor import (init_prange, min_checker, internal_prange)

            init_prange()
            result = []
            item_count = len(self._data)
            min_checker(item_count)
            for i in internal_prange(item_count):
                item = self._data[i]
                item_method = item.upper()
                result.append(item_method)

            return pandas.Series(result)

        return hpat_pandas_stringmethods_upper_parallel_impl

        def hpat_pandas_stringmethods_upper_impl(self):
            result = []
            item_count = len(self._data)
            for i in range(item_count):
                item = self._data[i]
                item_method = item.upper()
                result.append(item_method)

            return pandas.Series(result)

        return hpat_pandas_stringmethods_upper_impl

    Test: python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_split_filter

"""


import numpy
import pandas

import numba
from numba.extending import overload_method
from numba.types import (Boolean, Integer, NoneType,
                         Omitted, StringLiteral, UnicodeType)

from sdc.datatypes.common_functions import TypeChecker
from sdc.datatypes.hpat_pandas_stringmethods_types import StringMethodsType


_hpat_pandas_stringmethods_autogen_global_dict = {
    'pandas': pandas,
    'numpy': numpy,
    'numba': numba,
    'StringMethodsType': StringMethodsType,
    'TypeChecker': TypeChecker
}

_hpat_pandas_stringmethods_functions_params = {
    'cat': ', others=None, sep=None, na_rep=None, join="left"',
    'center': ', width, fillchar=" "',
    'contains': ', pat, case=True, flags=0, na=numpy.nan, regex=True',
    'count': ', pat, flags=0',
    'decode': ', encoding, errors="strict"',
    'encode': ', encoding, errors="strict"',
    'endswith': ', pat, na=numpy.nan',
    'extractall': ', pat, flags=0',
    'extract': ', pat, flags=0, expand=True',
    'findall': ', pat, flags=0',
    'find': ', sub, start=0, end=None',
    'get': ', i',
    'get_dummies': ', sep="|"',
    'index': ', sub, start=0, end=None',
    'join': ', sep',
    'ljust': ', width, fillchar=" "',
    'lstrip': ', to_strip=None',
    'match': ', pat, case=True, flags=0, na=numpy.nan',
    'normalize': ', form',
    'pad': ', width, side="left", fillchar=" "',
    'partition': ', sep=" ", expand=True',
    'repeat': ', repeats',
    'replace': ', pat, repl, n=-1, case=None, flags=0, regex=True',
    'rfind': ', sub, start=0, end=None',
    'rindex': ', sub, start=0, end=None',
    'rjust': ', width, fillchar=" "',
    'rpartition': ', sep=" ", expand=True',
    'rsplit': ', pat=None, n=-1, expand=False',
    'rstrip': ', to_strip=None',
    'slice_replace': ', start=None, stop=None, repl=None',
    'slice': ', start=None, stop=None, step=None',
    'split': ', pat=None, n=-1, expand=False',
    'startswith': ', pat, na=numpy.nan',
    'strip': ', to_strip=None',
    'translate': ', table',
    'wrap': ', width',
    'zfill': ', width',
}

_hpat_pandas_stringmethods_functions_template = """
# @overload_method(StringMethodsType, '{methodname}')
def hpat_pandas_stringmethods_{methodname}(self{methodparams}):
    \"\"\"
    Pandas Series method :meth:`pandas.core.strings.StringMethods.{methodname}()` implementation.

    Note: Unicode type of list elements are supported only. Numpy.NaN is not supported as elements.

    .. only:: developer

    Test: python -m sdc.runtests sdc.tests.test_strings.TestStrings.test_str2str
          python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_str2str
          python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_get
          python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_replace_noregex
          python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_split
          python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_contains_regex

    Parameters
    ----------
    self: :class:`pandas.core.strings.StringMethods`
        input arg
    other: {methodparams}
        input arguments decription in
        https://pandas.pydata.org/pandas-docs/version/0.25/reference/series.html#string-handling

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    \"\"\"

    ty_checker = TypeChecker('Method {methodname}().')
    ty_checker.check(self, StringMethodsType)

    def hpat_pandas_stringmethods_{methodname}_impl(self{methodparams}):
        item_count = len(self._data)
        result = [''] * item_count
        # result = numba.typed.List.empty_list(numba.types.unicode_type)

        for it in range(item_count):
            item = self._data._data[it]
            if len(item) > 0:
                result[it] = item.{methodname}({methodparams_call})
            else:
                result[it] = item

        return pandas.Series(result, self._data._index, name=self._data._name)

    return hpat_pandas_stringmethods_{methodname}_impl
"""


@overload_method(StringMethodsType, 'endswith')
def hpat_pandas_stringmethods_endswith(self, pat, na=None):
    """
    Pandas Series method :meth:`pandas.core.strings.StringMethods.endswith()` implementation.

    Note: Unicode type of list elements are supported only. Numpy.NaN is not supported as elements.

    .. only:: developer

    Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_endswith

    Parameters
    ----------
    self: :class:`pandas.core.strings.StringMethods`
        input arg
    pat: :obj:`str`
        Character sequence
    na: :obj:`bool`
        Object shown if element tested is not a string
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method endswith().')
    ty_checker.check(self, StringMethodsType)

    if not isinstance(pat, (StringLiteral, UnicodeType)):
        ty_checker.raise_exc(pat, 'str', 'pat')

    if not isinstance(na, (Boolean, NoneType, Omitted)) and na is not None:
        ty_checker.raise_exc(na, 'bool', 'na')

    def hpat_pandas_stringmethods_endswith_impl(self, pat, na=None):
        if na is not None:
            msg = 'Method endswith(). The object na\n expected: None'
            raise ValueError(msg)

        item_endswith = len(self._data)
        result = numpy.empty(item_endswith, numba.types.boolean)
        for idx, item in enumerate(self._data._data):
            result[idx] = item.endswith(pat)

        return pandas.Series(result, self._data._index, name=self._data._name)

    return hpat_pandas_stringmethods_endswith_impl


@overload_method(StringMethodsType, 'find')
def hpat_pandas_stringmethods_find(self, sub, start=0, end=None):
    """
    Pandas Series method :meth:`pandas.core.strings.StringMethods.find()` implementation.

    Note: Unicode type of list elements are supported only. Numpy.NaN is not supported as elements.

    .. only:: developer

    Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_find

    Parameters
    ----------
    self: :class:`pandas.core.strings.StringMethods`
        input arg
    sub: :obj:`str`
        Substring being searched
    start: :obj:`int`
        Left edge index
        *unsupported*
    end: :obj:`int`
        Right edge index
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method find().')
    ty_checker.check(self, StringMethodsType)

    if not isinstance(sub, (StringLiteral, UnicodeType)):
        ty_checker.raise_exc(sub, 'str', 'sub')

    accepted_types = (Integer, NoneType, Omitted)
    if not isinstance(start, accepted_types) and start != 0:
        ty_checker.raise_exc(start, 'None, int', 'start')

    if not isinstance(end, accepted_types) and end is not None:
        ty_checker.raise_exc(end, 'None, int', 'end')

    def hpat_pandas_stringmethods_find_impl(self, sub, start=0, end=None):
        if start != 0:
            raise ValueError('Method find(). The object start\n expected: 0')
        if end is not None:
            raise ValueError('Method find(). The object end\n expected: None')

        item_count = len(self._data)
        result = numpy.empty(item_count, numba.types.int64)
        for idx, item in enumerate(self._data._data):
            result[idx] = item.find(sub)

        return pandas.Series(result, self._data._index, name=self._data._name)

    return hpat_pandas_stringmethods_find_impl


@overload_method(StringMethodsType, 'isupper')
def hpat_pandas_stringmethods_isupper(self):
    """
    Pandas Series method :meth:`pandas.core.strings.StringMethods.isupper()` implementation.

    Note: Unicode type of list elements are supported only. Numpy.NaN is not supported as elements.

    .. only:: developer

    Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_str2str

    Parameters
    ----------
    self: :class:`pandas.core.strings.StringMethods`
        input arg

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method isupper().')
    ty_checker.check(self, StringMethodsType)

    def hpat_pandas_stringmethods_isupper_impl(self):
        item_count = len(self._data)
        result = numpy.empty(item_count, numba.types.boolean)
        for idx, item in enumerate(self._data._data):
            result[idx] = item.isupper()

        return pandas.Series(result, self._data._index, name=self._data._name)

    return hpat_pandas_stringmethods_isupper_impl


@overload_method(StringMethodsType, 'len')
def hpat_pandas_stringmethods_len(self):
    """
    Pandas Series method :meth:`pandas.core.strings.StringMethods.len()` implementation.

    Note: Unicode type of list elements are supported only. Numpy.NaN is not supported as elements.

    .. only:: developer

    Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_str_len1

    Parameters
    ----------
    self: :class:`pandas.core.strings.StringMethods`
        input arg

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method len().')
    ty_checker.check(self, StringMethodsType)

    def hpat_pandas_stringmethods_len_impl(self):
        item_count = len(self._data)
        result = numpy.empty(item_count, numba.types.int64)
        for idx, item in enumerate(self._data._data):
            result[idx] = len(item)

        return pandas.Series(result, self._data._index, name=self._data._name)

    return hpat_pandas_stringmethods_len_impl


def _hpat_pandas_stringmethods_autogen(method_name):
    """"
    The function generates a function for 'method_name' from source text that is created on the fly.
    """

    params = ""
    params_call = ""

    # get function parameters by name
    params_dict = _hpat_pandas_stringmethods_functions_params.get(method_name)
    if params_dict is not None:
        params = params_dict

    if len(params) > 0:
        """
        Translate parameters string for method

        For example:
            parameters for split(): ', pat=None, n=-1, expand=False'
                    translate into: 'pat, n, expand'
        """

        params_call_splitted = params.split(',')
        params_call_list = []
        for item in params_call_splitted:
            params_call_list.append(item.split("=")[0])
        params_call = ",".join(params_call_list)
        if len(params_call) > 1:
            params_call = params_call[2:]

    sourcecode = _hpat_pandas_stringmethods_functions_template.format(methodname=method_name,
                                                                      methodparams=params,
                                                                      methodparams_call=params_call)
    exec(sourcecode, _hpat_pandas_stringmethods_autogen_global_dict)

    global_dict_name = 'hpat_pandas_stringmethods_{methodname}'.format(methodname=method_name)
    return _hpat_pandas_stringmethods_autogen_global_dict[global_dict_name]


# _hpat_pandas_stringmethods_autogen_methods = sorted(dir(numba.types.misc.UnicodeType.__getattribute__.__qualname__))
_hpat_pandas_stringmethods_autogen_methods = ['upper', 'lower', 'lstrip', 'rstrip', 'strip']
"""
    This is the list of function which are autogenerated to be used from Numba directly.
"""

_hpat_pandas_stringmethods_autogen_exceptions = ['split', 'get', 'replace']

for method_name in _hpat_pandas_stringmethods_autogen_methods:
    if not (method_name.startswith('__') or method_name in _hpat_pandas_stringmethods_autogen_exceptions):
        overload_method(StringMethodsType, method_name)(_hpat_pandas_stringmethods_autogen(method_name))
