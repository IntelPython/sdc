# *****************************************************************************
# Copyright (c) 2019, Intel Corporation All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#     Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# *****************************************************************************

"""
| :class:`pandas.Series` functions and operators implementations in SDC
| Also, it contains Numba internal operators which are required for Series type handling
"""

import numba
import numpy
import operator
import pandas
import math
import sys

from numba.errors import TypingError
from numba.extending import overload, overload_method, overload_attribute
from numba.typing import signature
from numba.extending import intrinsic
from numba import (types, numpy_support, cgutils)
from numba.typed import Dict

import sdc
import sdc.datatypes.common_functions as common_functions
from sdc.datatypes.common_functions import (TypeChecker, check_index_is_numeric, find_common_dtype_from_numpy_dtypes,
                                            sdc_join_series_indexes)
from sdc.datatypes.hpat_pandas_series_rolling_types import _hpat_pandas_series_rolling_init
from sdc.datatypes.hpat_pandas_stringmethods_types import StringMethodsType
from sdc.datatypes.hpat_pandas_getitem_types import SeriesGetitemAccessorType
from sdc.hiframes.pd_series_type import SeriesType
from sdc.str_arr_ext import (StringArrayType, string_array_type, str_arr_is_na, str_arr_set_na,
                             num_total_chars, pre_alloc_string_array, cp_str_list_to_array)
from sdc.utils import to_array, sdc_overload, sdc_overload_method, sdc_overload_attribute
from sdc.datatypes import hpat_pandas_series_autogenerated


@sdc_overload(operator.getitem)
def hpat_pandas_series_accessor_getitem(self, idx):
    """
    Pandas Series operator :attr:`pandas.Series.get` implementation
    **Algorithm**: result = series[idx]

    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_static_getitem_series1

    Parameters
    ----------
    series: :obj:`pandas.Series`
           input series
    idx: :obj:`int`, :obj:`slice` or :obj:`pandas.Series`
        input index

    Returns
    -------
    :class:`pandas.Series` or an element of the underneath type
            object of :class:`pandas.Series`
    """

    _func_name = 'Operator getitem().'

    if not isinstance(self, SeriesGetitemAccessorType):
        return None

    accessor = self.accessor.literal_value

    if accessor == 'iloc':
        if isinstance(idx, (types.List, types.Array, types.SliceType)):
            def hpat_pandas_series_iloc_list_slice_impl(self, idx):
                result_data = self._series._data[idx]
                result_index = self._series.index[idx]
                return pandas.Series(result_data, result_index, self._series._name)

            return hpat_pandas_series_iloc_list_slice_impl

        if isinstance(idx, (int, types.Integer)):
            def hpat_pandas_series_iloc_impl(self, idx):
                return self._series._data[idx]

            return hpat_pandas_series_iloc_impl

        def hpat_pandas_series_iloc_callable_impl(self, idx):
            index = numpy.asarray(list(map(idx, self._series._data)))
            return pandas.Series(self._series._data[index], self._series.index[index], self._series._name)

        return hpat_pandas_series_iloc_callable_impl

        raise TypingError('{} The index must be an Integer, Slice or List of Integer or a callable.\
                    Given: {}'.format(_func_name, idx))

    if accessor == 'iat':
        if isinstance(idx, (int, types.Integer)):
            def hpat_pandas_series_iat_impl(self, idx):
                return self._series._data[idx]

            return hpat_pandas_series_iat_impl

        raise TypingError('{} The index must be a Integer. Given: {}'.format(_func_name, idx))

    if accessor == 'loc':
        # Note: Loc return Series
        # Note: Index 0 in slice not supported
        # Note: Loc slice and callable with String not implement
        index_is_none = (self.series.index is None or
                         isinstance(self.series.index, numba.types.misc.NoneType))
        if isinstance(idx, types.SliceType) and index_is_none:
            def hpat_pandas_series_loc_slice_noidx_impl(self, idx):
                max_slice = sys.maxsize
                start = idx.start
                stop = idx.stop
                if idx.stop == max_slice:
                    stop = max_slice - 1
                result_data = self._series._data[start:stop+1]
                result_index = numpy.arange(start, stop + 1)
                return pandas.Series(result_data, result_index, self._series._name)

            return hpat_pandas_series_loc_slice_noidx_impl

        if isinstance(idx, (int, types.Integer, types.UnicodeType, types.StringLiteral)):
            def hpat_pandas_series_loc_impl(self, idx):
                index = self._series.index
                mask = numpy.empty(len(self._series._data), numpy.bool_)
                for i in numba.prange(len(index)):
                    mask[i] = index[i] == idx
                return pandas.Series(self._series._data[mask], index[mask], self._series._name)

            return hpat_pandas_series_loc_impl

        raise TypingError('{} The index must be an Number, Slice, String, List, Array or a callable.\
                          Given: {}'.format(_func_name, idx))

    if accessor == 'at':
        if isinstance(idx, (int, types.Integer, types.UnicodeType, types.StringLiteral)):
            def hpat_pandas_series_at_impl(self, idx):
                index = self._series.index
                mask = numpy.empty(len(self._series._data), numpy.bool_)
                for i in numba.prange(len(index)):
                    mask[i] = index[i] == idx
                return self._series._data[mask]

            return hpat_pandas_series_at_impl

        raise TypingError('{} The index must be a Number or String. Given: {}'.format(_func_name, idx))

    raise TypingError('{} Unknown accessor. Only "loc", "iloc", "at", "iat" are supported.\
                      Given: {}'.format(_func_name, accessor))


@sdc_overload(operator.getitem)
def hpat_pandas_series_getitem(self, idx):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.get

    Limitations
    -----------
    Supported ``key`` can be one of the following:
        - Integer scalar, e.g. :obj:`series[0]`
        - A slice, e.g. :obj:`series[2:5]`
        - Another series

    Examples
    --------
    .. literalinclude:: ../../../examples/series_getitem.py
       :language: python
       :lines: 27-
       :caption: Getting Pandas Series elements
       :name: ex_series_getitem

    .. command-output:: python ./series_getitem.py
       :cwd: ../../../examples

    .. todo:: Fix SDC behavior and add the expected output of the > python ./series_getitem.py to the docstring

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series operator :attr:`pandas.Series.get` implementation
    **Algorithm**: result = series[idx]

    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_static_getitem_series1

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series
    idx: :obj:`int`, :obj:`slice` or :obj:`pandas.Series`
        input index

    Returns
    -------
    :class:`pandas.Series` or an element of the underneath type
            object of :class:`pandas.Series`
    """

    _func_name = 'Operator getitem().'

    if not isinstance(self, SeriesType):
        return None

    # Note: Getitem return Series
    index_is_none = self.index is None or isinstance(self.index, numba.types.misc.NoneType)
    index_is_none_or_numeric = index_is_none or (self.index and isinstance(self.index.dtype, types.Number))
    index_is_string = not index_is_none and isinstance(self.index.dtype, (types.UnicodeType, types.StringLiteral))

    if (
        isinstance(idx, types.Number) and index_is_none_or_numeric or
        (isinstance(idx, (types.UnicodeType, types.StringLiteral)) and index_is_string)
    ):
        def hpat_pandas_series_getitem_index_impl(self, idx):
            index = self.index
            mask = numpy.empty(len(self._data), numpy.bool_)
            for i in numba.prange(len(index)):
                mask[i] = index[i] == idx
            return pandas.Series(self._data[mask], index[mask], self._name)

        return hpat_pandas_series_getitem_index_impl

    if (isinstance(idx, types.Integer) and index_is_string):
        def hpat_pandas_series_idx_impl(self, idx):
            return self._data[idx]

        return hpat_pandas_series_idx_impl

    if isinstance(idx, types.SliceType):
        # Return slice for str values not implement
        def hpat_pandas_series_getitem_idx_slice_impl(self, idx):
            return pandas.Series(self._data[idx], self.index[idx], self._name)

        return hpat_pandas_series_getitem_idx_slice_impl

    if (
        isinstance(idx, (types.List, types.Array)) and
        isinstance(idx.dtype, (types.Boolean, bool))
    ):
        def hpat_pandas_series_getitem_idx_list_impl(self, idx):
            return pandas.Series(self._data[idx], self.index[idx], self._name)
        return hpat_pandas_series_getitem_idx_list_impl

    if (isinstance(self.index, types.NoneType) and isinstance(idx, SeriesType)):
        if isinstance(idx.data.dtype, (types.Boolean, bool)):
            def hpat_pandas_series_getitem_idx_list_impl(self, idx):
                index = numpy.arange(len(self._data))
                if (index != idx.index).sum() == 0:
                    return pandas.Series(self._data[idx._data], index[idx._data], self._name)

            return hpat_pandas_series_getitem_idx_list_impl

        def hpat_pandas_series_getitem_idx_list_impl(self, idx):
            res = numpy.copy(self._data[:len(idx._data)])
            index = numpy.arange(len(self._data))
            for i in numba.prange(len(res)):
                for j in numba.prange(len(index)):
                    if j == idx._data[i]:
                        res[i] = self._data[j]
            return pandas.Series(res, index[idx._data], self._name)
        return hpat_pandas_series_getitem_idx_list_impl

    if (isinstance(idx, SeriesType) and not isinstance(self.index, types.NoneType)):
        if isinstance(idx.data.dtype, (types.Boolean, bool)):
            # Series with str index not implement
            def hpat_pandas_series_getitem_idx_series_impl(self, idx):
                if (self._index != idx._index).sum() == 0:
                    return pandas.Series(self._data[idx._data], self._index[idx._data], self._name)

            return hpat_pandas_series_getitem_idx_series_impl

        def hpat_pandas_series_getitem_idx_series_impl(self, idx):
            index = self.index
            res = []
            for i in numba.prange(len(idx._data)):
                temp = []
                for j in numba.prange(len(index)):
                    if index[j] == idx._data[i]:
                        temp.append(self._data[j])
                res.append(temp)
            new_data = numpy.array([value for arr in res for value in arr])
            new_index = numpy.array([idx._data[arr] for arr in range(len(res)) for value in range(len(res[arr]))])
            return pandas.Series(new_data, new_index, self._name)

        return hpat_pandas_series_getitem_idx_series_impl

    raise TypingError('{} The index must be an Number, Slice, String, Boolean Array or a Series.\
                    Given: {}'.format(_func_name, idx))


@sdc_overload(operator.setitem)
def hpat_pandas_series_setitem(self, idx, value):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.set

    Examples
    --------
    .. literalinclude:: ../../../examples/series_setitem_int.py
       :language: python
       :lines: 27-
       :caption: Setting Pandas Series elements
       :name: ex_series_setitem

    .. code-block:: console

        > python ./series_setitem_int.py

            0    0
            1    4
            2    3
            3    2
            4    1
            dtype: int64

        > python ./series_setitem_slice.py

            0    5
            1    4
            2    0
            3    0
            4    0
            dtype: int64

        > python ./series_setitem_series.py

            0    5
            1    0
            2    3
            3    0
            4    1
            dtype: int64

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
     Pandas Series operator :attr:`pandas.Series.set` implementation

    Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_setitem*

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series
    idx: :obj:`int`, :obj:`slice` or :obj:`pandas.Series`
        input index
    value: :object
        input value

    Returns
    -------
    :class:`pandas.Series` or an element of the underneath type
            object of :class:`pandas.Series`
    """

    ty_checker = TypeChecker('Operator setitem.')
    ty_checker.check(self, SeriesType)

    if not (isinstance(idx, (types.Integer, types.SliceType, SeriesType))):
        ty_checker.raise_exc(idx, 'int, Slice, Series', 'idx')

    if not((isinstance(value, SeriesType) and isinstance(value.dtype, self.dtype)) or \
           isinstance(value, type(self.dtype))):
        ty_checker.raise_exc(value, self.dtype, 'value')

    if isinstance(idx, types.Integer) or isinstance(idx, types.SliceType):
        def hpat_pandas_series_setitem_idx_integer_impl(self, idx, value):
            """
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_value
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_slice
            """
            self._data[idx] = value
            return self

        return hpat_pandas_series_setitem_idx_integer_impl

    if isinstance(idx, SeriesType):
        def hpat_pandas_series_setitem_idx_series_impl(self, idx, value):
            """
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_series
            """
            super_index = idx._data
            self._data[super_index] = value
            return self

        return hpat_pandas_series_setitem_idx_series_impl


@sdc_overload_attribute(SeriesType, 'iloc')
def hpat_pandas_series_iloc(self):
    """
    Pandas Series method :meth:`pandas.Series.iloc` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_iloc*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series

    Returns
    -------
    :obj:`series`
        returns an object of :obj:`series`
    """

    _func_name = 'Attribute iloc().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_iloc_impl(self):
        return sdc.datatypes.hpat_pandas_getitem_types.series_getitem_accessor_init(self, 'iloc')

    return hpat_pandas_series_iloc_impl


@sdc_overload_attribute(SeriesType, 'loc')
def hpat_pandas_series_loc(self):
    """
    Pandas Series method :meth:`pandas.Series.loc` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_loc*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series

    Returns
    -------
    :obj:`series`
        returns an object of :obj:`series`
    """

    _func_name = 'Attribute loc().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_loc_impl(self):
        return sdc.datatypes.hpat_pandas_getitem_types.series_getitem_accessor_init(self, 'loc')

    return hpat_pandas_series_loc_impl


@sdc_overload_attribute(SeriesType, 'iat')
def hpat_pandas_series_iat(self):
    """
    Pandas Series method :meth:`pandas.Series.iat` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_iat*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series

    Returns
    -------
    :obj:`series`
        returns an object of :obj:`series`
    """

    _func_name = 'Attribute iat().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_iat_impl(self):
        return sdc.datatypes.hpat_pandas_getitem_types.series_getitem_accessor_init(self, 'iat')

    return hpat_pandas_series_iat_impl


@sdc_overload_attribute(SeriesType, 'at')
def hpat_pandas_series_at(self):
    """
    Pandas Series method :meth:`pandas.Series.at` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_at*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series

    Returns
    -------
    :obj:`series`
        returns an object of :obj:`series`
    """

    _func_name = 'Attribute at().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_at_impl(self):
        return sdc.datatypes.hpat_pandas_getitem_types.series_getitem_accessor_init(self, 'at')

    return hpat_pandas_series_at_impl


@sdc_overload_method(SeriesType, 'nsmallest')
def hpat_pandas_series_nsmallest(self, n=5, keep='first'):
    """
    Pandas Series method :meth:`pandas.Series.nsmallest` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_nsmallest*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    n: :obj:`int`, default 5
        Return this many ascending sorted values.
    keep: :obj:`str`, default 'first'
        When there are duplicate values that cannot all fit in a Series of n elements:
        first : return the first n occurrences in order of appearance.
        last : return the last n occurrences in reverse order of appearance.
        all : keep all occurrences. This can result in a Series of size larger than n.
        *unsupported*

    Returns
    -------
    :obj:`series`
         returns :obj:`series`
    """

    _func_name = 'Method nsmallest().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object\n given: {}\n expected: {}'.format(_func_name, self, 'series'))

    if not isinstance(n, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object n\n given: {}\n expected: {}'.format(_func_name, n, 'int'))

    if not isinstance(keep, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} The object keep\n given: {}\n expected: {}'.format(_func_name, keep, 'str'))

    def hpat_pandas_series_nsmallest_impl(self, n=5, keep='first'):
        if keep != 'first':
            raise ValueError("Method nsmallest(). Unsupported parameter. Given 'keep' != 'first'")

        # mergesort is used for stable sorting of repeated values
        indices = self._data.argsort(kind='mergesort')[:max(n, 0)]

        return self.take(indices)

    return hpat_pandas_series_nsmallest_impl


@sdc_overload_method(SeriesType, 'nlargest')
def hpat_pandas_series_nlargest(self, n=5, keep='first'):
    """
    Pandas Series method :meth:`pandas.Series.nlargest` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_nlargest*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    n: :obj:`int`, default 5
        Return this many ascending sorted values.
    keep: :obj:`str`, default 'first'
        When there are duplicate values that cannot all fit in a Series of n elements:
        first : return the first n occurrences in order of appearance.
        last : return the last n occurrences in reverse order of appearance.
        all : keep all occurrences. This can result in a Series of size larger than n.
        *unsupported*

    Returns
    -------
    :obj:`series`
         returns :obj:`series`
    """

    _func_name = 'Method nlargest().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object\n given: {}\n expected: {}'.format(_func_name, self, 'series'))

    if not isinstance(n, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object n\n given: {}\n expected: {}'.format(_func_name, n, 'int'))

    if not isinstance(keep, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} The object keep\n given: {}\n expected: {}'.format(_func_name, keep, 'str'))

    def hpat_pandas_series_nlargest_impl(self, n=5, keep='first'):
        if keep != 'first':
            raise ValueError("Method nlargest(). Unsupported parameter. Given 'keep' != 'first'")

        # data: [0, 1, -1, 1, 0] -> [1, 1, 0, 0, -1]
        # index: [0, 1,  2, 3, 4] -> [1, 3, 0, 4,  2] (not [3, 1, 4, 0, 2])
        # subtract 1 to ensure reverse ordering at boundaries
        indices = (-self._data - 1).argsort(kind='mergesort')[:max(n, 0)]

        return self.take(indices)

    return hpat_pandas_series_nlargest_impl


@sdc_overload_attribute(SeriesType, 'shape')
def hpat_pandas_series_shape(self):
    """
    Pandas Series attribute :attr:`pandas.Series.shape` implementation
    **Algorithm**: result = series.shape
    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shape1
    Parameters
    ----------
    series: :obj:`pandas.Series`
          input series
    Returns
    -------
    :obj:`tuple`
        a tuple of the shape of the underlying data
    """

    _func_name = 'Attribute shape.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_shape_impl(self):
        return self._data.shape

    return hpat_pandas_series_shape_impl


@sdc_overload_method(SeriesType, 'std')
def hpat_pandas_series_std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.std` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    level: :obj:`int`, :obj:`str`
        If the axis is a MultiIndex (hierarchical),
        count along a particular level, collapsing into a scalar
        *unsupported*
    ddof: :obj:`int`
        Delta Degrees of Freedom.
        The divisor used in calculations is N - ddof,
        where N represents the number of elements.
    numeric_only: :obj:`bool`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:`scalar`
         returns :obj:`scalar`
    """

    _func_name = 'Method std().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean, types.NoneType)) and skipna is not None:
        raise TypingError('{} The object must be a boolean. Given skipna: {}'.format(_func_name, skipna))

    if not isinstance(ddof, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object must be an integer. Given ddof: {}'.format(_func_name, ddof))

    for name, arg in [('axis', axis), ('level', level), ('numeric_only', numeric_only)]:
        if not isinstance(arg, (types.Omitted, types.NoneType)) and arg is not None:
            raise TypingError('{} Unsupported parameters. Given {}: {}'.format(_func_name, name, arg))

    def hpat_pandas_series_std_impl(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
        var = self.var(axis=axis, skipna=skipna, level=level, ddof=ddof, numeric_only=numeric_only)
        return var ** 0.5

    return hpat_pandas_series_std_impl


@sdc_overload_attribute(SeriesType, 'values')
def hpat_pandas_series_values(self):
    """
    Pandas Series attribute 'values' implementation.
        https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.values.html#pandas.Series.values
    Algorithm: result = series.values
    Where:
        series: pandas.series
        result: pandas.series as ndarray
    Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_values
    """

    _func_name = 'Attribute values.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_values_impl(self):
        return self._data

    return hpat_pandas_series_values_impl


@sdc_overload_method(SeriesType, 'value_counts')
def hpat_pandas_series_value_counts(self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.value_counts

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_value_counts.py
       :language: python
       :lines: 27-
       :caption: Getting the number of values excluding NaNs
       :name: ex_series_value_counts

    .. command-output:: python ./series/series_value_counts.py
       :cwd: ../../../examples

     .. note::

        Parameter bins and dropna for Strings are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.count <pandas.Series.count>`


    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.value_counts` implementation.

    Note: Elements with the same count might appear in result in a different order than in Pandas

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_value_counts*

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    normalize: :obj:`boolean`, default False
        If True then the object returned will contain the relative frequencies of the unique values
    sort: :obj: `boolean`, default True
        Sort by frequencies
    ascending: :obj:`boolean`, default False
        Sort in ascending order
    bins: :obj:`integer`, default None
        *unsupported*
    dropna: :obj:`boolean`, default True
        Skip counts of NaN

    Returns
    -------
    :returns :obj:`pandas.Series`
    """

    _func_name = 'Method value_counts().'

    ty_checker = TypeChecker('Method value_counts().')
    ty_checker.check(self, SeriesType)

    if not isinstance(normalize, (types.Omitted, types.Boolean, bool)) and normalize is True:
        ty_checker.raise_exc(normalize, 'boolean', 'normalize')

    if not isinstance(sort, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(sort, 'boolean', 'sort')

    if not isinstance(ascending, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(ascending, 'boolean', 'ascending')

    if not isinstance(bins, (types.Omitted, types.NoneType)) and bins is not None:
        ty_checker.raise_exc(bins, 'boolean', 'bins')

    if not isinstance(dropna, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(dropna, 'boolean', 'dropna')

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_value_counts_str_impl(
                self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):

            value_counts_dict = Dict.empty(
                key_type=types.unicode_type,
                value_type=types.intp
            )

            nan_counts = 0
            for i, value in enumerate(self._data):
                if str_arr_is_na(self._data, i):
                    if not dropna:
                        nan_counts += 1
                    continue

                value_counts_dict[value] = value_counts_dict.get(value, 0) + 1

            need_add_nan_count = not dropna and nan_counts

            values = [key for key in value_counts_dict]
            counts_as_list = [value_counts_dict[key] for key in value_counts_dict.keys()]
            values_len = len(values)

            if need_add_nan_count:
                # append a separate empty string for NaN elements
                values_len += 1
                values.append('')
                counts_as_list.append(nan_counts)

            counts = numpy.asarray(counts_as_list, dtype=numpy.intp)
            indexes_order = numpy.arange(values_len)
            if sort:
                indexes_order = counts.argsort()
                if not ascending:
                    indexes_order = indexes_order[::-1]

            counts_sorted = numpy.take(counts, indexes_order)
            values_sorted_by_count = [values[i] for i in indexes_order]

            # allocate the result index as a StringArray and copy values to it
            index_string_lengths = numpy.asarray([len(s) for s in values_sorted_by_count])
            index_total_chars = numpy.sum(index_string_lengths)
            result_index = pre_alloc_string_array(len(values_sorted_by_count), index_total_chars)
            cp_str_list_to_array(result_index, values_sorted_by_count)

            if need_add_nan_count:
                # set null bit for StringArray element corresponding to NaN element (was added as last in values)
                index_previous_nan_pos = values_len - 1
                for i in numpy.arange(values_len):
                    if indexes_order[i] == index_previous_nan_pos:
                        str_arr_set_na(result_index, i)
                        break

            return pandas.Series(counts_sorted, index=result_index, name=self._name)

        return hpat_pandas_series_value_counts_str_impl

    elif isinstance(self.dtype, types.Number):

        series_dtype = self.dtype
        def hpat_pandas_series_value_counts_number_impl(
                self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):

            value_counts_dict = Dict.empty(
                key_type=series_dtype,
                value_type=types.intp
            )

            zero_counts = 0
            is_zero_found = False
            for value in self._data:
                if (dropna and numpy.isnan(value)):
                    continue

                # Pandas hash-based value_count_float64 function doesn't distinguish between
                # positive and negative zeros, hence we count zero values separately and store
                # as a key the first zero value found in the Series
                if not value:
                    zero_counts += 1
                    if not is_zero_found:
                        zero_value = value
                        is_zero_found = True
                    continue

                value_counts_dict[value] = value_counts_dict.get(value, 0) + 1

            if zero_counts:
                value_counts_dict[zero_value] = zero_counts

            unique_values = numpy.asarray(
                list(value_counts_dict),
                dtype=self._data.dtype
            )
            value_counts = numpy.asarray(
                [value_counts_dict[key] for key in value_counts_dict],
                dtype=numpy.intp
            )

            indexes_order = numpy.arange(len(value_counts))
            if sort:
                indexes_order = value_counts.argsort()
                if not ascending:
                    indexes_order = indexes_order[::-1]

            sorted_unique_values = numpy.take(unique_values, indexes_order)
            sorted_value_counts = numpy.take(value_counts, indexes_order)

            return pandas.Series(sorted_value_counts, index=sorted_unique_values, name=self._name)

        return hpat_pandas_series_value_counts_number_impl

    return None


@sdc_overload_method(SeriesType, 'var')
def hpat_pandas_series_var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.var` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    level: :obj:`int`, :obj:`str`
        If the axis is a MultiIndex (hierarchical),
        count along a particular level, collapsing into a scalar
        *unsupported*
    ddof: :obj:`int`
        Delta Degrees of Freedom.
        The divisor used in calculations is N - ddof,
        where N represents the number of elements.
    numeric_only: :obj:`bool`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:`scalar`
         returns :obj:`scalar`
    """

    _func_name = 'Method var().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean, types.NoneType)) and skipna is not None:
        raise TypingError('{} The object must be a boolean. Given skipna: {}'.format(_func_name, skipna))

    if not isinstance(ddof, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object must be an integer. Given ddof: {}'.format(_func_name, ddof))

    for name, arg in [('axis', axis), ('level', level), ('numeric_only', numeric_only)]:
        if not isinstance(arg, (types.Omitted, types.NoneType)) and arg is not None:
            raise TypingError('{} Unsupported parameters. Given {}: {}'.format(_func_name, name, arg))

    def hpat_pandas_series_var_impl(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
        if skipna is None:
            skipna = True

        if skipna:
            valuable_length = len(self._data) - numpy.sum(numpy.isnan(self._data))
            if valuable_length <= ddof:
                return numpy.nan

            return numpy.nanvar(self._data) * valuable_length / (valuable_length - ddof)

        if len(self._data) <= ddof:
            return numpy.nan

        return self._data.var() * len(self._data) / (len(self._data) - ddof)

    return hpat_pandas_series_var_impl


@sdc_overload_attribute(SeriesType, 'index')
def hpat_pandas_series_index(self):
    """
    Pandas Series attribute :attr:`pandas.Series.index` implementation
    **Algorithm**: result = series.index
    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_index1
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_index2
    Parameters
    ----------
    series: :obj:`pandas.Series`
           input series
    Returns
    -------
    :class:`pandas.Series`
           the index of the Series
    """

    _func_name = 'Attribute index.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_index_none_impl(self):
            return numpy.arange(len(self._data))

        return hpat_pandas_series_index_none_impl
    else:
        def hpat_pandas_series_index_impl(self):
            return self._index

        return hpat_pandas_series_index_impl


@sdc_overload_method(SeriesType, 'rolling')
def hpat_pandas_series_rolling(self, window, min_periods=None, center=False,
                               win_type=None, on=None, axis=0, closed=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.rolling

    Examples
    --------
    .. literalinclude:: ../../../examples/series/rolling/series_rolling_min.py
       :language: python
       :lines: 27-
       :caption: Calculate the rolling minimum.
       :name: ex_series_rolling

    .. command-output:: python ./series/rolling/series_rolling_min.py
       :cwd: ../../../examples

    .. todo:: Add support of parameters ``center``, ``win_type``, ``on``, ``axis`` and ``closed``

    .. seealso::
        :ref:`expanding <pandas.Series.expanding>`
            Provides expanding transformations.
        :ref:`ewm <pandas.Series.ewm>`
            Provides exponential weighted functions.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series attribute :attr:`pandas.Series.rolling` implementation
    .. only:: developer

    Test: python -m sdc.runtests -k sdc.tests.test_rolling.TestRolling.test_series_rolling

    Parameters
    ----------
    series: :obj:`pandas.Series`
        Input Series.
    window: :obj:`int` or :obj:`offset`
        Size of the moving window.
    min_periods: :obj:`int`
        Minimum number of observations in window required to have a value.
    center: :obj:`bool`
        Set the labels at the center of the window.
        *unsupported*
    win_type: :obj:`str`
        Provide a window type.
        *unsupported*
    on: :obj:`str`
        Column on which to calculate the rolling window.
        *unsupported*
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    closed: :obj:`str`
        Make the interval closed on the ‘right’, ‘left’, ‘both’ or ‘neither’ endpoints.
        *unsupported*

    Returns
    -------
    :class:`pandas.Series.rolling`
        Output class to manipulate with input data.
    """

    ty_checker = TypeChecker('Method rolling().')
    ty_checker.check(self, SeriesType)

    if not isinstance(window, types.Integer):
        ty_checker.raise_exc(window, 'int', 'window')

    minp_accepted = (types.Omitted, types.NoneType, types.Integer)
    if not isinstance(min_periods, minp_accepted) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'None, int', 'min_periods')

    center_accepted = (types.Omitted, types.Boolean)
    if not isinstance(center, center_accepted) and center is not False:
        ty_checker.raise_exc(center, 'bool', 'center')

    str_types = (types.Omitted, types.NoneType, types.StringLiteral, types.UnicodeType)
    if not isinstance(win_type, str_types) and win_type is not None:
        ty_checker.raise_exc(win_type, 'str', 'win_type')

    if not isinstance(on, str_types) and on is not None:
        ty_checker.raise_exc(on, 'str', 'on')

    axis_accepted = (types.Omitted, types.Integer, types.StringLiteral, types.UnicodeType)
    if not isinstance(axis, axis_accepted) and axis != 0:
        ty_checker.raise_exc(axis, 'int, str', 'axis')

    if not isinstance(closed, str_types) and closed is not None:
        ty_checker.raise_exc(closed, 'str', 'closed')

    nan_minp = isinstance(min_periods, (types.Omitted, types.NoneType)) or min_periods is None

    def hpat_pandas_series_rolling_impl(self, window, min_periods=None, center=False,
                                        win_type=None, on=None, axis=0, closed=None):
        if window < 0:
            raise ValueError('window must be non-negative')

        if nan_minp == True:  # noqa
            minp = window
        else:
            minp = min_periods

        if minp < 0:
            raise ValueError('min_periods must be >= 0')
        if minp > window:
            raise ValueError('min_periods must be <= window')

        if center != False:  # noqa
            raise ValueError('Method rolling(). The object center\n expected: False')

        if win_type is not None:
            raise ValueError('Method rolling(). The object win_type\n expected: None')

        if on is not None:
            raise ValueError('Method rolling(). The object on\n expected: None')

        if axis != 0:
            raise ValueError('Method rolling(). The object axis\n expected: 0')

        if closed is not None:
            raise ValueError('Method rolling(). The object closed\n expected: None')

        return _hpat_pandas_series_rolling_init(self, window, minp, center,
                                                win_type, on, axis, closed)

    return hpat_pandas_series_rolling_impl


@sdc_overload_attribute(SeriesType, 'size')
def hpat_pandas_series_size(self):
    """
    Pandas Series attribute :attr:`pandas.Series.size` implementation

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_size

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series

    Returns
    -------
    :class:`pandas.Series`
        Return the number of elements in the underlying data.
    """

    _func_name = 'Attribute size.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_size_impl(self):
        return len(self._data)

    return hpat_pandas_series_size_impl


@sdc_overload_attribute(SeriesType, 'str')
def hpat_pandas_series_str(self):
    """
    Pandas Series attribute :attr:`pandas.Series.str` implementation

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_get

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series

    Returns
    -------
    :class:`pandas.core.strings.StringMethods`
        Output class to manipulate with input data.
    """

    _func_name = 'Attribute str.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.List, types.UnicodeType)):
        msg = '{}  Can only use .str accessor with string values. Given: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    def hpat_pandas_series_str_impl(self):
        return pandas.core.strings.StringMethods(self)

    return hpat_pandas_series_str_impl


@sdc_overload_attribute(SeriesType, 'ndim')
def hpat_pandas_series_ndim(self):
    """
    Pandas Series attribute :attr:`pandas.Series.ndim` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_getattr_ndim

    Parameters
    ----------
    self: :obj:`pandas.Series`
           input series

    Returns
    -------
    :obj:`int`
           Number of dimensions of the underlying data, by definition 1
    """

    _func_name = 'Attribute ndim.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_ndim_impl(self):
        return 1

    return hpat_pandas_series_ndim_impl


@sdc_overload_attribute(SeriesType, 'T')
def hpat_pandas_series_T(self):
    """
    Pandas Series attribute :attr:`pandas.Series.T` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_getattr_T

    Parameters
    ----------
    self: :obj:`pandas.Series`
           input series

    Returns
    -------
    :obj:`numpy.ndarray`
         An array representing the underlying data
    """

    _func_name = 'Attribute T.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_T_impl(self):
        return self._data

    return hpat_pandas_series_T_impl


@sdc_overload(len)
def hpat_pandas_series_len(self):
    """
    Pandas Series operator :func:`len` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_len

    Parameters
    ----------
    series: :class:`pandas.Series`

    Returns
    -------
    :obj:`int`
        number of items in the object
    """

    _func_name = 'Operator len().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_len_impl(self):
        return len(self._data)

    return hpat_pandas_series_len_impl


@sdc_overload_method(SeriesType, 'astype')
def hpat_pandas_series_astype(self, dtype, copy=True, errors='raise'):
    """
    Pandas Series method :meth:`pandas.Series.astype` implementation.
    Cast a pandas object to a specified dtype dtype
    .. only:: developer
        Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_astype*

    Parameters
    -----------
    dtype : :obj:`numpy.dtype` or :obj:`dict`
               Use a numpy.dtype or Python type to cast entire pandas object to the same type.
               Alternatively, use {col: dtype, …}, where col is a column label and dtype is a numpy.dtype
               or Python type to cast one or more of the DataFrame’s columns to column-specific types.

    copy : :obj:`bool`, default :obj:`True`
            Return a copy when True
            Currently copy=False is not supported
    errors : :obj:`str`, default :obj:`'raise'`
            Control raising of exceptions on invalid data for provided dtype.
                * raise : allow exceptions to be raised
                * ignore : suppress exceptions. On error return original object
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` Cast a :obj:`pandas.Series` to a specified dtype dtype
    """

    _func_name = 'Method astype().'
    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(copy, (types.Omitted, bool, types.Boolean)):
        raise TypingError('{} The object must be a boolean. Given copy: {}'.format(_func_name, copy))

    if (not isinstance(errors, (types.Omitted, str, types.UnicodeType, types.StringLiteral)) and
        errors in ('raise', 'ignore')):
        raise TypingError('{} The object must be a string literal. Given errors: {}'.format(_func_name, errors))

    # Return StringArray for astype(str) or astype('str')
    def hpat_pandas_series_astype_to_str_impl(self, dtype, copy=True, errors='raise'):
        num_chars = 0
        arr_len = len(self._data)

        # Get total chars for new array
        for i in numba.parfor.internal_prange(arr_len):
            item = self._data[i]
            num_chars += len(str(item))  # TODO: check NA

        data = sdc.str_arr_ext.pre_alloc_string_array(arr_len, num_chars)
        for i in numba.parfor.internal_prange(arr_len):
            item = self._data[i]
            data[i] = str(item)  # TODO: check NA

        return pandas.Series(data, self._index, self._name)

    # Return npytypes.Array from npytypes.Array for astype(types.functions.NumberClass), example - astype(np.int64)
    def hpat_pandas_series_astype_numba_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data.astype(dtype), self._index, self._name)

    # Return npytypes.Array from npytypes.Array for astype(types.StringLiteral), example - astype('int64')
    def hpat_pandas_series_astype_literal_type_numba_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data.astype(numpy.dtype(dtype)), self._index, self._name)

    # Return self
    def hpat_pandas_series_astype_no_modify_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data, self._index, self._name)


    if ((isinstance(dtype, types.Function) and dtype.typing_key == str)
        or (isinstance(dtype, types.StringLiteral) and dtype.literal_value == 'str')):
        return hpat_pandas_series_astype_to_str_impl

    # Needs Numba astype impl support converting unicode_type to NumberClass and other types
    if isinstance(self.data, StringArrayType):
        if isinstance(dtype, types.functions.NumberClass) and errors == 'raise':
            raise TypingError(f'Needs Numba astype impl support converting unicode_type to {dtype}')
        if isinstance(dtype, types.StringLiteral) and errors == 'raise':
            try:
                literal_value = numpy.dtype(dtype.literal_value)
            except:
                pass # Will raise the exception later
            else:
                raise TypingError(f'Needs Numba astype impl support converting unicode_type to {dtype.literal_value}')

    if isinstance(self.data, types.npytypes.Array) and isinstance(dtype, types.functions.NumberClass):
        return hpat_pandas_series_astype_numba_impl

    if isinstance(self.data, types.npytypes.Array) and isinstance(dtype, types.StringLiteral):
        try:
            literal_value = numpy.dtype(dtype.literal_value)
        except:
            pass # Will raise the exception later
        else:
            return hpat_pandas_series_astype_literal_type_numba_impl

    # Raise error if dtype is not supported
    if errors == 'raise':
        raise TypingError(f'{_func_name} The object must be a supported type. Given dtype: {dtype}')
    else:
        return hpat_pandas_series_astype_no_modify_impl


@sdc_overload_method(SeriesType, 'shift')
def hpat_pandas_series_shift(self, periods=1, freq=None, axis=0, fill_value=None):
    """
    Pandas Series method :meth:`pandas.Series.shift` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_full
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_fill_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    periods: :obj:`int`
        Number of periods to shift. Can be positive or negative.
    freq: :obj:`DateOffset`, :obj:`tseries.offsets`, :obj:`timedelta`, :obj:`str`
        Offset to use from the tseries module or time rule (e.g. ‘EOM’).
        *unsupported*
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    fill_value : :obj:`int`, :obj:`float`
        The scalar value to use for newly introduced missing values.

    Returns
    -------
    :obj:`scalar`
         returns :obj:`series` object
    """

    _func_name = 'Method shift().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(fill_value, (types.Omitted, types.Number, types.NoneType)) and fill_value is not None:
        raise TypingError('{} The object must be a number. Given fill_value: {}'.format(_func_name, fill_value))

    if not isinstance(freq, (types.Omitted, types.NoneType)) and freq is not None:
        raise TypingError('{} Unsupported parameters. Given freq: {}'.format(_func_name, freq))

    if not isinstance(axis, (types.Omitted, int, types.Integer)) and not axis:
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    fill_is_default = isinstance(fill_value, (types.Omitted, types.NoneType)) or fill_value is None
    series_np_dtype = [numpy_support.as_dtype(self.data.dtype)]
    fill_np_dtype = [numpy.float64 if fill_is_default else numpy_support.as_dtype(fill_value)]

    fill_dtype = types.float64 if fill_is_default else fill_value
    common_dtype = find_common_dtype_from_numpy_dtypes([], [self.data.dtype, fill_dtype])

    if fill_is_default:
        def hpat_pandas_series_shift_impl(self, periods=1, freq=None, axis=0, fill_value=None):
            if axis != 0:
                raise TypingError('Method shift(). Unsupported parameters. Given axis != 0')

            arr = numpy.empty(shape=len(self._data), dtype=common_dtype)
            if periods > 0:
                arr[:periods] = numpy.nan
                arr[periods:] = self._data[:-periods]
            elif periods < 0:
                arr[periods:] = numpy.nan
                arr[:periods] = self._data[-periods:]
            else:
                arr[:] = self._data

            return pandas.Series(data=arr, index=self._index, name=self._name)

        return hpat_pandas_series_shift_impl

    def hpat_pandas_series_shift_impl(self, periods=1, freq=None, axis=0, fill_value=None):
        if axis != 0:
            raise TypingError('Method shift(). Unsupported parameters. Given axis != 0')

        arr = numpy.empty(len(self._data), dtype=common_dtype)
        if periods > 0:
            arr[:periods] = fill_value
            arr[periods:] = self._data[:-periods]
        elif periods < 0:
            arr[periods:] = fill_value
            arr[:periods] = self._data[-periods:]
        else:
            arr[:] = self._data

        return pandas.Series(data=arr, index=self._index, name=self._name)

    return hpat_pandas_series_shift_impl


@sdc_overload_method(SeriesType, 'isin')
def hpat_pandas_series_isin(self, values):
    """
    Pandas Series method :meth:`pandas.Series.isin` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isin_list1
    Parameters
    -----------
    values : :obj:`list` or :obj:`set` object
               specifies values to look for in the series
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object indicating if each element of self is in values
    """

    _func_name = 'Method isin().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(values, (types.Set, types.List)):
        raise TypingError(
            '{} The argument must be set or list-like object. Given values: {}'.format(_func_name, values))

    def hpat_pandas_series_isin_impl(self, values):
        # TODO: replace with below line when Numba supports np.isin in nopython mode
        # return pandas.Series(np.isin(self._data, values))
        return pandas.Series(data=[(x in values) for x in self._data], index=self._index, name=self._name)

    return hpat_pandas_series_isin_impl


@sdc_overload_method(SeriesType, 'append')
def hpat_pandas_series_append(self, to_append, ignore_index=False, verify_integrity=False):
    """
    Pandas Series method :meth:`pandas.Series.append` implementation.

    .. only:: developer

        Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_append*

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    to_append : :obj:`pandas.Series` object or :obj:`list` or :obj:`set`
        Series (or list or tuple of Series) to append with self
    ignore_index: :obj:`bool`, default False
        If True, do not use the index labels.
        Supported as literal value only
    verify_integrity: :obj:`bool`, default False
        If True, raise Exception on creating index with duplicates.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
        returns :obj:`pandas.Series` object
        Concatenated Series

    """

    _func_name = 'Method append().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not (isinstance(to_append, SeriesType)
            or (isinstance(to_append, (types.UniTuple, types.List)) and isinstance(to_append.dtype, SeriesType))):
        raise TypingError(
            '{} The argument must be a pandas.series or list/tuple of pandas.series. \
            Given to_append: {}'.format(_func_name, to_append))

    # currently we will always raise this in the end, i.e. if no impl was found
    # TODO: find a way to stop compilation early and not proceed with unliteral step
    if not (isinstance(ignore_index, types.Literal) and isinstance(ignore_index, types.Boolean)
            or isinstance(ignore_index, types.Omitted)
            or ignore_index is False):
        raise TypingError(
            '{} The ignore_index must be a literal Boolean constant. Given: {}'.format(_func_name, ignore_index))

    if not (verify_integrity is False or isinstance(verify_integrity, types.Omitted)):
        raise TypingError(
            '{} Unsupported parameters. Given verify_integrity: {}'.format(_func_name, verify_integrity))

    # ignore_index value has to be known at compile time to select between implementations with different signatures
    ignore_index_is_false = (common_functions.has_literal_value(ignore_index, False)
                             or common_functions.has_python_value(ignore_index, False)
                             or isinstance(ignore_index, types.Omitted))
    to_append_is_series = isinstance(to_append, SeriesType)

    if ignore_index_is_false:
        def hpat_pandas_series_append_impl(self, to_append, ignore_index=False, verify_integrity=False):
            if to_append_is_series == True:  # noqa
                new_data = common_functions.hpat_arrays_append(self._data, to_append._data)
                new_index = common_functions.hpat_arrays_append(self.index, to_append.index)
            else:
                data_arrays_to_append = [series._data for series in to_append]
                index_arrays_to_append = [series.index for series in to_append]
                new_data = common_functions.hpat_arrays_append(self._data, data_arrays_to_append)
                new_index = common_functions.hpat_arrays_append(self.index, index_arrays_to_append)

            return pandas.Series(new_data, new_index)

        return hpat_pandas_series_append_impl

    else:
        def hpat_pandas_series_append_ignore_index_impl(self, to_append, ignore_index=False, verify_integrity=False):

            if to_append_is_series == True:  # noqa
                new_data = common_functions.hpat_arrays_append(self._data, to_append._data)
            else:
                arrays_to_append = [series._data for series in to_append]
                new_data = common_functions.hpat_arrays_append(self._data, arrays_to_append)

            return pandas.Series(new_data, None)

        return hpat_pandas_series_append_ignore_index_impl


@sdc_overload_method(SeriesType, 'copy')
def hpat_pandas_series_copy(self, deep=True):
    """
    Pandas Series method :meth:`pandas.Series.copy` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_str1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_int1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_deep

    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    deep: :obj:`bool`, default :obj:`True`
        Make a deep copy, including a copy of the data and the indices.
        With deep=False neither the indices nor the data are copied.
        [SDC limitations]:
            - deep=False: shallow copy of index is not supported

    Returns
    -------
    :obj:`pandas.Series` or :obj:`pandas.DataFrame`
        Object type matches caller.
    """

    ty_checker = TypeChecker('Method Series.copy().')
    ty_checker.check(self, SeriesType)

    if not isinstance(deep, (types.Omitted, types.Boolean)) and not deep:
        ty_checker.raise_exc(self.data, 'boolean', 'deep')

    if isinstance(self.index, types.NoneType):
        def hpat_pandas_series_copy_impl(self, deep=True):
            if deep:
                return pandas.Series(data=self._data.copy(), name=self._name)
            else:
                return pandas.Series(data=self._data, name=self._name)
        return hpat_pandas_series_copy_impl
    else:
        def hpat_pandas_series_copy_impl(self, deep=True):
            if deep:
                return pandas.Series(data=self._data.copy(), index=self._index.copy(), name=self._name)
            else:
                # Shallow copy of index is not supported yet
                return pandas.Series(data=self._data, index=self._index.copy(), name=self._name)
        return hpat_pandas_series_copy_impl


@sdc_overload_method(SeriesType, 'corr')
def hpat_pandas_series_corr(self, other, method='pearson', min_periods=None):
    """
    Pandas Series method :meth:`pandas.Series.corr` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr_unsupported_dtype
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr_unsupported_period

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    other: :obj:`pandas.Series`
        input series
    method:
        *unsupported
    min_periods: :obj:`int`, default None

    Returns
    -------
    :obj:`float`
         returns :obj:`float` object
    """


    ty_checker = TypeChecker('Method corr().')
    ty_checker.check(self, SeriesType)

    ty_checker.check(other, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data, 'number', 'self.data')

    if not isinstance(other.data.dtype, types.Number):
        ty_checker.raise_exc(other.data, 'number', 'other.data')

    if not isinstance(min_periods, (int, types.Integer, types.Omitted, types.NoneType)) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'int64', 'min_periods')

    def hpat_pandas_series_corr_impl(self, other, method='pearson', min_periods=None):

        if min_periods is None:
            min_periods = 1

        if len(self._data) == 0 or len(other._data) == 0:
            return numpy.nan

        self_arr = self._data[:min(len(self._data), len(other._data))]
        other_arr = other._data[:min(len(self._data), len(other._data))]

        invalid = numpy.isnan(self_arr) | numpy.isnan(other_arr)
        if invalid.any():
            self_arr = self_arr[~invalid]
            other_arr = other_arr[~invalid]

        if len(self_arr) < min_periods:
            return numpy.nan

        new_self = pandas.Series(self_arr)
        new_other = pandas.Series(other_arr)

        n = new_self.count()
        ma = new_self.sum()
        mb = new_other.sum()
        a = n * (self_arr * other_arr).sum() - ma * mb
        b1 = n * (self_arr * self_arr).sum() - ma * ma
        b2 = n * (other_arr * other_arr).sum() - mb * mb

        if b1 == 0 or b2 == 0:
            return numpy.nan

        return a / numpy.sqrt(b1 * b2)

    return hpat_pandas_series_corr_impl


@sdc_overload_method(SeriesType, 'head')
def hpat_pandas_series_head(self, n=5):
    """
    Pandas Series method :meth:`pandas.Series.head` implementation.

    .. only:: developer
       Test: python -m -k sdc.runtests sdc.tests.test_series.TestSeries.test_series_head*

    Parameters
    -----------
    n: :obj:`int`, default 5
        input argument, default 5
    Returns
    -------
    :obj:`pandas.Series`
        returns: The first n rows of the caller object.
    """

    _func_name = 'Method head().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(n, (types.Integer, types.Omitted)) and n != 5:
        raise TypingError('{} The parameter must be an integer type. Given type n: {}'.format(_func_name, n))

    if isinstance(self.index, types.NoneType):
        def hpat_pandas_series_head_impl(self, n=5):
            return pandas.Series(data=self._data[:n], name=self._name)

        return hpat_pandas_series_head_impl
    else:
        def hpat_pandas_series_head_index_impl(self, n=5):
            return pandas.Series(data=self._data[:n], index=self._index[:n], name=self._name)

        return hpat_pandas_series_head_index_impl


@sdc_overload_method(SeriesType, 'groupby')
def hpat_pandas_series_groupby(
        self,
        by=None,
        axis=0,
        level=None,
        as_index=True,
        sort=True,
        group_keys=True,
        squeeze=False,
        observed=False):
    """
    Pandas Series method :meth:`pandas.Series.groupby` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_groupby_count
    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    by: :obj:`pandas.Series` object
        Used to determine the groups for the groupby
    axis:
        *unsupported*
    level:
        *unsupported*
    as_index:
        *unsupported*
    sort:
        *unsupported*
    group_keys:
        *unsupported*
    squeeze:
        *unsupported*
    observed:
        *unsupported*
    Returns
    -------
    :obj:`pandas.SeriesGroupBy`
         returns :obj:`pandas.SeriesGroupBy` object
    """

    _func_name = 'Method Series.groupby().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if by is None and axis is None:
        raise TypingError("{} You have to supply one of 'by' or 'axis' parameters".format(_func_name))

    if level is not None and not isinstance(level, (types.Integer, types.NoneType, types.Omitted)):
        raise TypingError("{} 'level' must be an Integer. Given: {}".format(_func_name, level))

    def hpat_pandas_series_groupby_impl(
            self,
            by=None,
            axis=0,
            level=None,
            as_index=True,
            sort=True,
            group_keys=True,
            squeeze=False,
            observed=False):
        # TODO Needs to implement parameters value check
        # if level is not None and (level < -1 or level > 0):
        #     raise ValueError("Method Series.groupby(). level > 0 or level < -1 only valid with MultiIndex")

        return pandas.core.groupby.SeriesGroupBy(self)

    return hpat_pandas_series_groupby_impl


@sdc_overload_method(SeriesType, 'isnull')
@sdc_overload_method(SeriesType, 'isna')
def hpat_pandas_series_isna(self):
    """
    Pandas Series method :meth:`pandas.Series.isna` and :meth:`pandas.Series.isnull` implementation.

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isna1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_str_isna1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isnull1

    Parameters
    -----------
    self : :obj:`pandas.Series` object
               input argument

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method isna/isnull().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if isinstance(self.data.dtype, (types.Integer, types.Float)):

        def hpat_pandas_series_isna_impl(self):
            return pandas.Series(data=numpy.isnan(self._data), index=self._index, name=self._name)

        return hpat_pandas_series_isna_impl

    if isinstance(self.data.dtype, types.UnicodeType):

        def hpat_pandas_series_isna_impl(self):
            result = numpy.empty(len(self._data), numpy.bool_)
            byte_size = 8
            # iterate over bits in StringArrayType null_bitmap and fill array indicating if array's element are NaN
            for i in range(len(self._data)):
                bmap_idx = i // byte_size
                bit_idx = i % byte_size
                bmap = self._data.null_bitmap[bmap_idx]
                bit_value = (bmap >> bit_idx) & 1
                result[i] = bit_value == 0
            return pandas.Series(result, index=self._index, name=self._name)

        return hpat_pandas_series_isna_impl


@sdc_overload_method(SeriesType, 'notna')
def hpat_pandas_series_notna(self):
    """
    Pandas Series method :meth:`pandas.Series.notna` implementation.

    .. only:: developer

        Test: python -m -k sdc.runtests sdc.tests.test_series.TestSeries.test_series_notna*

    Parameters
    -----------
    self : :obj:`pandas.Series` object
        input series

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method notna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_notna_impl(self):
            return pandas.Series(numpy.invert(numpy.isnan(self._data)), index=self._index, name=self._name)

        return hpat_pandas_series_notna_impl

    if isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_notna_impl(self):
            result = self.isna()
            return pandas.Series(numpy.invert(result._data), index=self._index, name=self._name)

        return hpat_pandas_series_notna_impl


@sdc_overload_method(SeriesType, 'ne')
def hpat_pandas_series_ne(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.ne` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method ne().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_ne_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data != other._data)

        return hpat_pandas_series_ne_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_ne_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data != other)

        return hpat_pandas_series_ne_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'add')
def hpat_pandas_series_add(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.add


    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_add.py
       :language: python
       :lines: 27-
       :caption: Getting the addition of Series and other
       :name: ex_series_add

    .. command-output:: python ./series/series_add.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.radd <pandas.Series.radd>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.add` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method add().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_add_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data + other._data)

        return hpat_pandas_series_add_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_add_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method add(). The object axis\n expected: 0')

            return pandas.Series(self._data + other)

        return hpat_pandas_series_add_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'sub')
def hpat_pandas_series_sub(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.sub` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method sub().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_sub_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data - other._data)

        return hpat_pandas_series_sub_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_sub_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data - other)

        return hpat_pandas_series_sub_number_impl

    raise TypingError('{} The object must be a pandas.series or scalar. Given other: {}'.format(_func_name, other))


@sdc_overload_method(SeriesType, 'sum')
def hpat_pandas_series_sum(
    self,
    axis=None,
    skipna=None,
    level=None,
    numeric_only=None,
    min_count=0,
):
    """
    Pandas Series method :meth:`pandas.Series.sum` implementation.

    .. only:: developer

        Tests:
            python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum1
            # python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum2

    Parameters
    ----------
    self: :class:`pandas.Series`
        input series
    axis:
        *unsupported*
    skipna: :obj:`bool`, default :obj:`True`
        Exclude NA/null values when computing the result.
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    min_count:
        *unsupported*

    Returns
    -------
    :obj:`float`
        scalar or Series (if level specified)
    """

    _func_name = 'Method sum().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.Omitted)) or axis is None):
        raise TypingError('{} The axis must be an Integer. Currently unsupported. Given: {}'.format(_func_name, axis))

    if not (isinstance(skipna, (types.Boolean, types.Omitted)) or skipna is None):
        raise TypingError('{} The skipna must be a Boolean. Given: {}'.format(_func_name, skipna))

    if not (isinstance(level, (types.Integer, types.StringLiteral, types.Omitted)) or level is None):
        raise TypingError(
            '{} The level must be an Integer or level name. Currently unsupported. Given: {}'.format(
                _func_name, level))

    if not (isinstance(numeric_only, (types.Boolean, types.Omitted)) or numeric_only is None):
        raise TypingError(
            '{} The numeric_only must be a Boolean. Currently unsupported. Given: {}'.format(
                _func_name, numeric_only))

    if not (isinstance(min_count, (types.Integer, types.Omitted)) or min_count == 0):
        raise TypingError(
            '{} The min_count must be an Integer. Currently unsupported. Given: {}'.format(
                _func_name, min_count))

    def hpat_pandas_series_sum_impl(
        self,
        axis=None,
        skipna=None,
        level=None,
        numeric_only=None,
        min_count=0,
    ):
        """
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum1
        """
        if skipna is None:
            skipna = True
        if skipna:
            return numpy.nansum(self._data)
        return numpy.sum(self._data)

    return hpat_pandas_series_sum_impl


@sdc_overload_method(SeriesType, 'take')
def hpat_pandas_series_take(self, indices, axis=0, is_copy=False):
    """
    Pandas Series method :meth:`pandas.Series.take` implementation.
    .. only:: developer
       Tests: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_default
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_default_unboxing
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_int
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_int_unboxing
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_str
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_str_unboxing
    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    indices: :obj:`array-like`
         An array of ints indicating which positions to take
    axis: {0 or `index`, 1 or `columns`, None}, default 0
        The axis on which to select elements. 0 means that we are selecting rows,
        1 means that we are selecting columns.
        *unsupported*
    is_copy: :obj:`bool`, default True
        Whether to return a copy of the original object or not.
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object containing the elements taken from the object
    """

    ty_checker = TypeChecker('Method take().')
    ty_checker.check(self, SeriesType)

    if (not isinstance(axis, (int, types.Integer, str, types.UnicodeType, types.StringLiteral, types.Omitted))
        and axis not in (0, 'index')):
        ty_checker.raise_exc(axis, 'integer or string', 'axis')

    if not isinstance(is_copy, (bool, types.Boolean, types.Omitted)) and is_copy is not False:
        ty_checker.raise_exc(is_copy, 'boolean', 'is_copy')

    if not isinstance(indices, (types.List, types.Array)):
        ty_checker.raise_exc(indices, 'array-like', 'indices')

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_take_noindex_impl(self, indices, axis=0, is_copy=False):
            local_data = [self._data[i] for i in indices]

            return pandas.Series(local_data, indices)

        return hpat_pandas_series_take_noindex_impl

    def hpat_pandas_series_take_impl(self, indices, axis=0, is_copy=False):
        local_data = [self._data[i] for i in indices]
        local_index = [self._index[i] for i in indices]

        return pandas.Series(local_data, local_index)

    return hpat_pandas_series_take_impl


@sdc_overload_method(SeriesType, 'idxmax')
def hpat_pandas_series_idxmax(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.idxmax` implementation.
    .. only:: developer
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_str_idx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_noidx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_idx

    Parameters
    -----------
    axis :  :obj:`int`, :obj:`str`, default: None
            Axis along which the operation acts
            0/None - row-wise operation
            1      - column-wise operation
            *unsupported*
    skipna:  :obj:`bool`, default: True
            exclude NA/null values
            *unsupported*
    Returns
    -------
    :obj:`pandas.Series.index` or nan
            returns: Label of the minimum value.
    """

    _func_name = 'Method idxmax().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Numeric values supported only. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean, bool)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None):
        raise TypingError("{} 'axis' unsupported. Given: {}".format(_func_name, axis))

    if not (isinstance(skipna, types.Omitted) or skipna is True):
        raise TypingError("{} 'skipna' unsupported. Given: {}".format(_func_name, skipna))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_idxmax_impl(self, axis=None, skipna=True):

            return numpy.argmax(self._data)

        return hpat_pandas_series_idxmax_impl
    else:
        def hpat_pandas_series_idxmax_index_impl(self, axis=None, skipna=True):
            # no numpy.nanargmax is supported by Numba at this time
            result = numpy.argmax(self._data)
            return self._index[int(result)]

        return hpat_pandas_series_idxmax_index_impl


@sdc_overload_method(SeriesType, 'mul')
def hpat_pandas_series_mul(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.mul

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_mul.py
       :language: python
       :lines: 27-
       :caption: Element-wise multiplication of two Series
       :name: ex_series_mul

    .. command-output:: python ./series/series_mul.py
       :cwd: ../../../examples

     .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rmul <pandas.Series.rmul>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.mul` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method mul().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(level, types.Omitted) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if not isinstance(fill_value, types.Omitted) and fill_value is not None:
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not isinstance(axis, types.Omitted) and axis != 0:
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_mul_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """
            if axis != 0:
                raise ValueError('Method mul(). The object axis\n expected: 0')

            return pandas.Series(self._data * other._data)

        return hpat_pandas_series_mul_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_mul_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method mul(). The object axis\n expected: 0')

            return pandas.Series(self._data * other)

        return hpat_pandas_series_mul_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'div')
def hpat_pandas_series_div(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.div

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_div.py
       :language: python
       :lines: 27-
       :caption: Element-wise division of one Series by another (binary operator div)
       :name: ex_series_div

    .. command-output:: python ./series/series_div.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rdiv <pandas.Series.rdiv>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.div` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method div().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(level, types.Omitted) or level is None):
        ty_checker.raise_exc(level, 'None', 'level')

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_div_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            if axis != 0:
                raise ValueError('Method div(). The object axis\n expected: 0')

            return pandas.Series(self._data / other._data)

        return hpat_pandas_series_div_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_div_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method div(). The object axis\n expected: 0')

            return pandas.Series(self._data / other)

        return hpat_pandas_series_div_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'truediv')
def hpat_pandas_series_truediv(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.truediv

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_truediv.py
       :language: python
       :lines: 27-
       :caption: Element-wise division of one Series by another (binary operator truediv)
       :name: ex_series_truediv

    .. command-output:: python ./series/series_truediv.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rtruediv <pandas.Series.rtruediv>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series :meth:`pandas.Series.truediv` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method truediv().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(level, types.Omitted) or level is None):
        ty_checker.raise_exc(level, 'None', 'level')

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_truediv_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            if axis != 0:
                raise ValueError('Method truediv(). The object axis\n expected: 0')

            return pandas.Series(self._data / other._data)

        return hpat_pandas_series_truediv_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_truediv_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method truediv(). The object axis\n expected: 0')

            return pandas.Series(self._data / other)

        return hpat_pandas_series_truediv_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'floordiv')
def hpat_pandas_series_floordiv(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.floordiv` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method floordiv().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_floordiv_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data // other._data)

        return hpat_pandas_series_floordiv_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_floordiv_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data // other)

        return hpat_pandas_series_floordiv_number_impl

    raise TypingError('{} The object must be a pandas.series or scalar. Given other: {}'.format(_func_name, other))


@sdc_overload_method(SeriesType, 'pow')
def hpat_pandas_series_pow(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.pow` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method pow().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_pow_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data ** other._data)

        return hpat_pandas_series_pow_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_pow_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data ** other)

        return hpat_pandas_series_pow_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'prod')
def hpat_pandas_series_prod(self, axis=None, skipna=True, level=None, numeric_only=None, min_count=0):
    """
    Pandas Series method :meth:`pandas.Series.prod` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_prod

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    axis: {index (0)}
        Axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default :obj:`True`
        Exclude nan values when computing the result
    level: :obj:`int`, :obj:`str`, default :obj:`None`
        If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.
        *unsupported*
    numeric_only: :obj:`bool`, default :obj:`None`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*
    min_count: :obj:`int`, default 0
        The required number of valid values to perform the operation.
        If fewer than min_count non-NA values are present the result will be NA.
        *unsupported*

    Returns
    -------
    :obj:
        Returns scalar or Series (if level specified)
    """

    _func_name = 'Method prod().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError('{} Non numeric values unsupported. Given: {}'.format(_func_name, self.data.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None) \
            or not (isinstance(min_count, types.Omitted) or min_count == 0):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}, min_count: {}'.format(
                _func_name, axis, level, numeric_only, min_count))

    def hpat_pandas_series_prod_impl(self, axis=None, skipna=True, level=None, numeric_only=None, min_count=0):
        if skipna:
            return numpy.nanprod(self._data)
        else:
            return numpy.prod(self._data)

    return hpat_pandas_series_prod_impl


@sdc_overload_method(SeriesType, 'quantile')
def hpat_pandas_series_quantile(self, q=0.5, interpolation='linear'):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.quantile

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_quantile.py
       :language: python
       :lines: 27-
       :caption: Computing quantile for the Series
       :name: ex_series_quantile

    .. command-output:: python ./series/series_quantile.py
       :cwd: ../../../examples

    .. note::

        Parameter interpolation is currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        `numpy.absolute <https://docs.scipy.org/doc/numpy/reference/generated/numpy.percentile.html#numpy.percentile>`_


    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.quantile` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_quantile
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_quantile_q_vector
    Parameters
    -----------
    q : :obj: float or array-like object, default 0.5
        the quantile(s) to compute
    interpolation: 'linear', 'lower', 'higher', 'midpoint', 'nearest', default `linear`
        *unsupported* by Numba
    Returns
    -------
    :obj:`pandas.Series` or float
    """

    _func_name = 'Method quantile().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(interpolation, types.Omitted) and interpolation is not 'linear':
        ty_checker.raise_exc(interpolation, 'str', 'interpolation')

    if not isinstance(q, (int, float, list, types.Number, types.Omitted, types.List)):
        ty_checker.raise_exc(q, 'int, float, list', 'q')

    def hpat_pandas_series_quantile_impl(self, q=0.5, interpolation='linear'):

        return numpy.quantile(self._data, q)

    return hpat_pandas_series_quantile_impl


@sdc_overload_method(SeriesType, 'rename')
def hpat_pandas_series_rename(self, index=None, copy=True, inplace=False, level=None):
    """
    Pandas Series method :meth:`pandas.Series.rename` implementation.
    Alter Series index labels or name.
    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_rename

    Parameters
    -----------
    index : :obj:`scalar` or `hashable sequence` or `dict` or `function`
               Dict-like or functions are transformations to apply to the index.
               Scalar or hashable sequence-like will alter the Series.name attribute.
               Only scalar value is supported.
    copy : :obj:`bool`, default :obj:`True`
               Whether to copy underlying data.
    inplace : :obj:`bool`, default :obj:`False`
               Whether to return a new Series. If True then value of copy is ignored.
    level : :obj:`int` or `str`
               In case of a MultiIndex, only rename labels in the specified level.
               *Not supported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` with index labels or name altered.
    """

    ty_checker = TypeChecker('Method rename().')
    ty_checker.check(self, SeriesType)

    if not isinstance(index, (types.Omitted, types.UnicodeType,
                              types.StringLiteral, str,
                              types.Integer, types.Boolean,
                              types.Hashable, types.Float,
                              types.NPDatetime, types.NPTimedelta,
                              types.Number)) and index is not None:
        ty_checker.raise_exc(index, 'string', 'index')

    if not isinstance(copy, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(copy, 'boolean', 'copy')

    if not isinstance(inplace, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(inplace, 'boolean', 'inplace')

    if not isinstance(level, (types.Omitted, types.UnicodeType,
                              types.StringLiteral, types.Integer)) and level is not None:
        ty_checker.raise_exc(level, 'Integer or srting', 'level')

    def hpat_pandas_series_rename_idx_impl(self, index=None, copy=True, inplace=False, level=None):
        if copy is True:
            series_data = self._data.copy()
            series_index = self._index.copy()
        else:
            series_data = self._data
            series_index = self._index

        return pandas.Series(data=series_data, index=series_index, name=index)

    def hpat_pandas_series_rename_noidx_impl(self, index=None, copy=True, inplace=False, level=None):
        if copy is True:
            series_data = self._data.copy()
        else:
            series_data = self._data

        return pandas.Series(data=series_data, index=self._index, name=index)

    if isinstance(self.index, types.NoneType):
        return hpat_pandas_series_rename_noidx_impl
    return hpat_pandas_series_rename_idx_impl


@sdc_overload_method(SeriesType, 'min')
def hpat_pandas_series_min(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.min` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_min
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_min_param
    Parameters
    -----------
    axis:
        *unsupported*
    skipna: :obj:`bool` object
        Exclude nan values when computing the result
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    Returns
    -------
    :obj:
         returns :obj: scalar
    """

    _func_name = 'Method min().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not True:
        raise TypingError(
            '{} The parameter must be a boolean type. Given type skipna: {}'.format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}'.format(_func_name, axis, level,
                                                                                            numeric_only))

    def hpat_pandas_series_min_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmin(self._data)

        return self._data.min()

    return hpat_pandas_series_min_impl


@sdc_overload_method(SeriesType, 'max')
def hpat_pandas_series_max(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.max

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_max.py
       :language: python
       :lines: 27-
       :caption: Getting the maximum value of Series elements
       :name: ex_series_max

    .. command-output:: python ./series/series_max.py
       :cwd: ../../../examples

    .. note::

        Parameters axis, level, numeric_only are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.sum <pandas.Series.sum>`
            Return the sum.
        :ref:`Series.min <pandas.Series.min>`
            Return the minimum.
        :ref:`Series.max <pandas.Series.max>`
            Return the maximum.
        :ref:`Series.idxmin <pandas.Series.idxmin>`
            Return the index of the minimum.
        :ref:`Series.idxmax <pandas.Series.idxmax>`
            Return the index of the maximum.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.max` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_max
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_max_param
    Parameters
    -----------
    axis:
        *unsupported*
    skipna: :obj:`bool` object
        Exclude nan values when computing the result
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    Returns
    -------
    :obj:
         returns :obj: scalar
    """

    _func_name = 'Method max().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not True:
        ty_checker.raise_exc(skipna, 'bool', 'skipna')

    if not isinstance(axis, types.Omitted) and axis is not None:
        ty_checker.raise_exc(axis, 'None', 'axis')

    if not isinstance(level, types.Omitted) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if not isinstance(numeric_only, types.Omitted) and numeric_only is not None:
        ty_checker.raise_exc(numeric_only, 'None', 'numeric_only')

    def hpat_pandas_series_max_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmax(self._data)

        return self._data.max()

    return hpat_pandas_series_max_impl


@sdc_overload_method(SeriesType, 'mean')
def hpat_pandas_series_mean(self, axis=None, skipna=None, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.mean` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_mean

    Parameters
    -----------
    axis: {index (0)}
        Axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default True
        Exclude NA/null values when computing the result.
    level: :obj:`int` or level name, default None
        If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.
        *unsupported*
    numeric_only: :obj:`bool`, default None
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data. Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:
         Return the mean of the values for the requested axis.
    """

    _func_name = 'Method mean().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not None:
        raise TypingError(
            '{} The parameter must be a boolean type. Given type skipna: {}'.format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}'.format(_func_name, axis, level,
                                                                                            numeric_only))

    def hpat_pandas_series_mean_impl(self, axis=None, skipna=None, level=None, numeric_only=None):
        if skipna is None:
            skipna = True

        if skipna:
            return numpy.nanmean(self._data)

        return self._data.mean()

    return hpat_pandas_series_mean_impl


@sdc_overload_method(SeriesType, 'mod')
def hpat_pandas_series_mod(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.mod` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method mod().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_mod_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data % other._data)

        return hpat_pandas_series_mod_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_mod_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data % other)

        return hpat_pandas_series_mod_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'eq')
def hpat_pandas_series_eq(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.eq` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method eq().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_eq_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data == other._data)

        return hpat_pandas_series_eq_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_eq_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data == other)

        return hpat_pandas_series_eq_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'ge')
def hpat_pandas_series_ge(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.ge` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method ge().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_ge_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data >= other._data)

        return hpat_pandas_series_ge_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_ge_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data >= other)

        return hpat_pandas_series_ge_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'idxmin')
def hpat_pandas_series_idxmin(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.idxmin` implementation.

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_str
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_str_idx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_no
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_int
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_noidx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_idx

    Parameters
    -----------
    axis :  :obj:`int`, :obj:`str`, default: None
            Axis along which the operation acts
            0/None - row-wise operation
            1      - column-wise operation
            *unsupported*
    skipna:  :obj:`bool`, default: True
            exclude NA/null values
            *unsupported*

    Returns
    -------
    :obj:`pandas.Series.index` or nan
            returns: Label of the minimum value.
    """

    _func_name = 'Method idxmin().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Numeric values supported only. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean, bool)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None):
        raise TypingError("{} 'axis' unsupported. Given: {}".format(_func_name, axis))

    if not (isinstance(skipna, types.Omitted) or skipna is True):
        raise TypingError("{} 'skipna' unsupported. Given: {}".format(_func_name, skipna))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_idxmin_impl(self, axis=None, skipna=True):

            return numpy.argmin(self._data)

        return hpat_pandas_series_idxmin_impl
    else:
        def hpat_pandas_series_idxmin_index_impl(self, axis=None, skipna=True):
            # no numpy.nanargmin is supported by Numba at this time
            result = numpy.argmin(self._data)
            return self._index[int(result)]

        return hpat_pandas_series_idxmin_index_impl


@sdc_overload_method(SeriesType, 'lt')
def hpat_pandas_series_lt(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.lt` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method lt().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_lt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data < other._data)

        return hpat_pandas_series_lt_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_lt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data < other)

        return hpat_pandas_series_lt_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'gt')
def hpat_pandas_series_gt(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.gt` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method gt().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_gt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data > other._data)

        return hpat_pandas_series_gt_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_gt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data > other)

        return hpat_pandas_series_gt_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'le')
def hpat_pandas_series_le(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.le` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method le().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_le_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data <= other._data)

        return hpat_pandas_series_le_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_le_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data <= other)

        return hpat_pandas_series_le_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'abs')
def hpat_pandas_series_abs(self):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.abs


    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_abs.py
       :language: python
       :lines: 27-
       :caption: Getting the absolute value of each element in Series
       :name: ex_series_abs

    .. command-output:: python ./series/series_abs.py
       :cwd: ../../../examples

    .. seealso::

        `numpy.absolute <https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html>`_
            Calculate the absolute value element-wise.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series method :meth:`pandas.Series.abs` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_abs1
    Parameters
    -----------
    self: :obj:`pandas.Series`
          input series
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` containing the absolute value of elements
    """

    _func_name = 'Method abs().'

    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(self.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} The function only applies to elements that are all numeric. Given data type: {}'.format(_func_name,
                                                                                                        self.dtype))

    def hpat_pandas_series_abs_impl(self):
        return pandas.Series(numpy.abs(self._data))

    return hpat_pandas_series_abs_impl


@sdc_overload_method(SeriesType, 'unique')
def hpat_pandas_series_unique(self):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.unique

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_unique.py
       :language: python
       :lines: 27-
       :caption: Getting unique values in Series
       :name: ex_series_unique

    .. command-output:: python ./series/series_unique.py
       :cwd: ../../../examples

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.unique` implementation.
    Note: Return values order is unspecified
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique_sorted
    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    Returns
    -------
    :obj:`numpy.array`
         returns :obj:`numpy.array` ndarray
    """

    ty_checker = TypeChecker('Method unique().')
    ty_checker.check(self, SeriesType)

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_unique_str_impl(self):
            '''
            Returns sorted unique elements of an array
            Note: Can't use Numpy due to StringArrayType has no ravel() for noPython mode.
            Also, NotImplementedError: unicode_type cannot be represented as a Numpy dtype

            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique_str
            '''

            str_set = set(self._data)
            return to_array(str_set)

        return hpat_pandas_series_unique_str_impl

    def hpat_pandas_series_unique_impl(self):
        '''
        Returns sorted unique elements of an array

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique
        '''

        return numpy.unique(self._data)

    return hpat_pandas_series_unique_impl


@sdc_overload_method(SeriesType, 'cumsum')
def hpat_pandas_series_cumsum(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.cumsum` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_full
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_unsupported_axis

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    *args:
        *unsupported*

    Returns
    -------
    :obj:`scalar`, :obj:`pandas.Series`
         returns :obj:`scalar` or :obj:`pandas.Series` object
    """

    _func_name = 'Method cumsum().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(axis, (types.Omitted, types.NoneType)) and axis is not None:
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    def hpat_pandas_series_cumsum_impl(self, axis=None, skipna=True):
        if skipna:
            # nampy.nancumsum replaces NANs with 0, series.cumsum does not, so replace back 0 with NANs
            local_data = numpy.nancumsum(self._data)
            local_data[numpy.isnan(self._data)] = numpy.nan
            return pandas.Series(local_data)

        return pandas.Series(self._data.cumsum())

    return hpat_pandas_series_cumsum_impl


@sdc_overload_method(SeriesType, 'nunique')
def hpat_pandas_series_nunique(self, dropna=True):
    """
    Pandas Series method :meth:`pandas.Series.nunique` implementation.

    Note: Unsupported mixed numeric and string data
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_nunique
    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    dropna: :obj:`bool`, default True
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method nunique().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.data, StringArrayType):

        def hpat_pandas_series_nunique_str_impl(self, dropna=True):
            """
            It is better to merge with Numeric branch
            """

            data = self._data
            if dropna:
                nan_mask = self.isna()
                data = self._data[~nan_mask._data]
            unique_values = set(data)
            return len(unique_values)

        return hpat_pandas_series_nunique_str_impl

    def hpat_pandas_series_nunique_impl(self, dropna=True):
        """
        This function for Numeric data because NumPy dosn't support StringArrayType
        Algo looks a bit ambigous because, currently, set() can not be used with NumPy with Numba JIT
        """

        data_mask_for_nan = numpy.isnan(self._data)
        nan_exists = numpy.any(data_mask_for_nan)
        data_no_nan = self._data[~data_mask_for_nan]
        data_set = set(data_no_nan)
        if dropna or not nan_exists:
            return len(data_set)
        else:
            return len(data_set) + 1

    return hpat_pandas_series_nunique_impl


@sdc_overload_method(SeriesType, 'count')
def hpat_pandas_series_count(self, level=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.count

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_count.py
       :language: python
       :lines: 27-
       :caption: Counting non-NaN values in Series
       :name: ex_series_count

    .. command-output:: python ./series/series_count.py
       :cwd: ../../../examples

    .. note::

        Parameter level is currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.value_counts <pandas.Series.value_counts>`
        :ref:`Series.value_counts <pandas.Series.value_counts>`
        :ref:`Series.str.len <pandas.Series.str.len>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.count` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_count
    Parameters

    -----------
    self: :obj:`pandas.Series`
          input series
    level:  :obj:`int` or name
           *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method count().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(level, (types.Omitted, types.NoneType)) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_count_str_impl(self, level=None):

            nan_mask = self.isna()
            return numpy.sum(nan_mask._data == 0)

        return hpat_pandas_series_count_str_impl

    def hpat_pandas_series_count_impl(self, level=None):
        """
        Return number of non-NA/null observations in the object
        Returns number of unique elements in the object
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_count
        """
        data_no_nan = self._data[~numpy.isnan(self._data)]
        return len(data_no_nan)

    return hpat_pandas_series_count_impl


@sdc_overload_method(SeriesType, 'median')
def hpat_pandas_series_median(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.median` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median_skipna_default1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median_skipna_false1

    Parameters
    -----------
    self: :obj:`pandas.Series`
          input series
    axis: :obj:`int` or :obj:`string` {0 or `index`, None}, default None
        The axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default True
        exclude NA/null values when computing the result
    level: :obj:`int` or :obj:`string`, default None
         *unsupported*
    numeric_only: :obj:`bool` or None, default None
         *unsupported*

    Returns
    -------
    :obj:`float` or :obj:`pandas.Series` (if level is specified)
         median of values in the series

    """

    _func_name = 'Method median().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(self.dtype, types.Number):
        raise TypingError(
            '{} The function only applies to elements that are all numeric. Given data type: {}'.format(
                _func_name, self.dtype))

    if not (isinstance(axis, (types.Integer, types.UnicodeType, types.Omitted)) or axis is None):
        raise TypingError(
            '{} The axis must be an Integer or a String. Currently unsupported. Given: {}'.format(
                _func_name, axis))

    if not (isinstance(skipna, (types.Boolean, types.Omitted)) or skipna):
        raise TypingError('{} The is_copy must be a boolean. Given: {}'.format(_func_name, skipna))

    if not ((level is None or isinstance(level, types.Omitted))
            and (numeric_only is None or isinstance(numeric_only, types.Omitted))
            and (axis is None or isinstance(axis, types.Omitted))
            ):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, numeric_only: {}, axis: {}'.format(
                _func_name, level, numeric_only, axis))

    def hpat_pandas_series_median_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmedian(self._data)

        return numpy.median(self._data)

    return hpat_pandas_series_median_impl


@sdc_overload_method(SeriesType, 'argsort')
def hpat_pandas_series_argsort(self, axis=0, kind='quicksort', order=None):
    """
    Pandas Series method :meth:`pandas.Series.argsort` implementation.

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_argsort*

    Parameters
    -----------
    self: :class:`pandas.Series`
        input series
    axis: :obj:`int`
        Has no effect but is accepted for compatibility with numpy.
        *unsupported*
    kind: :obj:'str', {'mergesort', 'quicksort', 'heapsort'}, default: 'quicksort'
        Choice of sorting algorithm. See np.sort for more information. 'mergesort' is the only stable algorithm
        *uses python func - sorted() for str and numpy func - sort() for num*
        *'heapsort' unsupported*
    order: :obj:`str` or  :obj:`list of str`, default: None
        Has no effect but is accepted for compatibility with numpy.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
         returns: Positions of values within the sort order with -1 indicating nan values.
    """

    _func_name = 'Method argsort().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Non-numeric type unsupported. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(axis, types.Omitted) or isinstance(axis, types.Integer) or axis == 0):
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    if not isinstance(kind, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Non-string type unsupported. Given kind: {}'.format(_func_name, kind))

    if not isinstance(order, (str, types.UnicodeType, types.StringLiteral, types.Omitted, types.NoneType, types.List))\
            and order is not None:
        raise TypingError('{} Unsupported parameters. Given order: {}'.format(_func_name, order))

    if not isinstance(self.index, types.NoneType):
        def hpat_pandas_series_argsort_idx_impl(self, axis=0, kind='quicksort', order=None):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method argsort(). Unsupported parameter. Given 'kind' != 'quicksort' or 'mergesort'")
            if kind == 'mergesort':
                #It is impossible to use numpy.argsort(self._data, kind=kind) since numba gives typing error
                sort = numpy.argsort(self._data, kind='mergesort')
            else:
                sort = numpy.argsort(self._data)
            na = self.isna().sum()
            result = numpy.empty(len(self._data), dtype=numpy.int64)
            na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
            if kind == 'mergesort':
                sort_nona = numpy.argsort(self._data[~na_data_arr], kind='mergesort')
            else:
                sort_nona = numpy.argsort(self._data[~na_data_arr])
            q = 0
            for id, i in enumerate(sort):
                if id in set(sort[len(self._data) - na:]):
                    q += 1
                else:
                    result[id] = sort_nona[id - q]
            for i in sort[len(self._data) - na:]:
                result[i] = -1

            return pandas.Series(result, self._index)

        return hpat_pandas_series_argsort_idx_impl

    def hpat_pandas_series_argsort_noidx_impl(self, axis=0, kind='quicksort', order=None):
        if kind != 'quicksort' and kind != 'mergesort':
            raise ValueError("Method argsort(). Unsupported parameter. Given 'kind' != 'quicksort' or 'mergesort'")
        if kind == 'mergesort':
            sort = numpy.argsort(self._data, kind='mergesort')
        else:
            sort = numpy.argsort(self._data)
        na = self.isna().sum()
        result = numpy.empty(len(self._data), dtype=numpy.int64)
        na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
        if kind == 'mergesort':
            sort_nona = numpy.argsort(self._data[~na_data_arr], kind='mergesort')
        else:
            sort_nona = numpy.argsort(self._data[~na_data_arr])
        q = 0
        for id, i in enumerate(sort):
            if id in set(sort[len(self._data) - na:]):
                q += 1
            else:
                result[id] = sort_nona[id - q]
        for i in sort[len(self._data) - na:]:
            result[i] = -1

        return pandas.Series(result)

    return hpat_pandas_series_argsort_noidx_impl


@sdc_overload_method(SeriesType, 'sort_values')
def hpat_pandas_series_sort_values(self, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last'):
    """
    Pandas Series method :meth:`pandas.Series.sort_values` implementation.

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_sort_values*

    Parameters
    -----------
    self: :class:'pandas.Series'
        input series
    axis: 0 or :obj:'pandas.Series.index', default: 0
        Axis to direct sorting.
        *unsupported*
    ascending: :obj:'bool', default: True
        If True, sort values in ascending order, otherwise descending.
    kind: :obj:'str', {'mergesort', 'quicksort', 'heapsort'}, default: 'quicksort'
        Choice of sorting algorithm.
        *uses python func - sorted() for str and numpy func - sort() for num*
        *'heapsort' unsupported*
    na_position: {'first' or 'last'}, default 'last'
        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
    """

    _func_name = 'Method sort_values().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, types.Omitted) or isinstance(axis, types.Integer) or axis == 0):
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    if not (isinstance(ascending, types.Omitted) or isinstance(ascending, types.Boolean) or ascending is True or False):
        raise TypingError('{} Unsupported parameters. Given ascending: {}'.format(_func_name, ascending))

    if not isinstance(kind, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Non-string type unsupported. Given kind: {}'.format(_func_name, kind))

    if not isinstance(na_position, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Unsupported parameters. Given na_position: {}'.format(_func_name, na_position))

    if isinstance(self.index, types.NoneType) and isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_sort_values_str_noidx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            index = numpy.arange(len(self._data))
            my_index = numpy.arange(len(self._data))
            used_index = numpy.full((len(self._data)), -1)
            result = sorted(self._data)
            cycle = range(len(self._data))
            if not ascending:
                result = result[::-1]
                cycle = range(len(self._data) - 1, -1, -1)
            result_index = index.copy()
            for i in range(len(result_index)):
                find = 0
                for search in cycle:
                    check = 0
                    for j in used_index:
                        if my_index[search] == j:
                            check = 1
                    if (self._data[search] == result[i]) and check == 0 and find == 0:
                        result_index[i] = index[search]
                        used_index[i] = my_index[search]
                        find = 1
            na = self.isna().sum()
            num = 0
            for i in self.isna():
                j = len(result_index) - na
                if i and used_index[j] == -1:
                    result_index[j] = index[num]
                    used_index[j] = my_index[num]
                    na -= 1
                num += 1

            return pandas.Series(result, result_index)

        return hpat_pandas_series_sort_values_str_noidx_impl

    if isinstance(self.index, types.NoneType) and isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_sort_values_num_noidx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            na = self.isna().sum()
            indices = numpy.arange(len(self._data))
            if kind == 'mergesort':
                # It is impossible to use numpy.argsort(self._data, kind=kind) since numba gives typing error
                index_result = numpy.argsort(self._data, kind='mergesort')
            else:
                index_result = numpy.argsort(self._data)
            result = numpy.sort(self._data)
            i = len(self._data) - na
            index_result[i:] = index_result[i:][::-1]
            if not ascending:
                index_result[:i] = index_result[:i][::-1]
                result[:i] = result[:i][::-1]
            for i in range(len(index_result)):
                indices[i] = index_result[i]

            return pandas.Series(result, indices)

        return hpat_pandas_series_sort_values_num_noidx_impl

    if isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_sort_values_str_idx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            index = self._index
            my_index = numpy.arange(len(self._data))
            used_index = numpy.full((len(self._data)), -1)
            result = sorted(self._data)
            cycle = range(len(self._data))
            if not ascending:
                result = result[::-1]
                cycle = range(len(self._data) - 1, -1, -1)
            result_index = self._index.copy()
            for i in range(len(result_index)):
                find = 0
                for search in cycle:
                    check = 0
                    for j in used_index:
                        if my_index[search] == j:
                            check = 1
                    if (self._data[search] == result[i]) and check == 0 and find == 0:
                        result_index[i] = index[search]
                        used_index[i] = my_index[search]
                        find = 1
            na = self.isna().sum()
            num = 0
            for i in self.isna():
                j = len(result_index) - na
                if i and used_index[j] == -1:
                    result_index[j] = index[num]
                    used_index[j] = my_index[num]
                    na -= 1
                num += 1

            return pandas.Series(result, result_index)

        return hpat_pandas_series_sort_values_str_idx_impl

    if isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_sort_values_num_idx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            na = self.isna().sum()
            indices = self._index.copy()
            if kind == 'mergesort':
                index_result = numpy.argsort(self._data, kind='mergesort')
            else:
                index_result = numpy.argsort(self._data)
            result = numpy.sort(self._data)
            i = len(self._data) - na
            index_result[i:] = index_result[i:][::-1]
            if not ascending:
                index_result[:i] = index_result[:i][::-1]
                result[:i] = result[:i][::-1]
            for i in range(len(index_result)):
                indices[i] = self._index[index_result[i]]

            return pandas.Series(result, indices)

        return hpat_pandas_series_sort_values_num_idx_impl


@sdc_overload_method(SeriesType, 'dropna')
def hpat_pandas_series_dropna(self, axis=0, inplace=False):
    """
    Pandas Series method :meth:`pandas.Series.dropna` implementation.

    .. only:: developer
       Tests: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_dropna*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int` or :obj:`string` {0 or `index`}, default 0
        There is only one axis to drop values from.
    inplace: :obj:`bool`, default False
        If True, do operation inplace and return None.
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object with NA entries dropped from it.
    """

    _func_name = 'Method dropna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.StringLiteral, types.UnicodeType, types.Omitted)) or axis == 0):
        raise TypingError('{} The axis must be an Integer or String. Given: {}'.format(_func_name, axis))

    if not (inplace is False or isinstance(inplace, types.Omitted)):
        raise TypingError('{} Unsupported parameters. Given inplace: {}'.format(_func_name, inplace))

    def hpat_pandas_series_dropna_impl(self, axis=0, inplace=False):
        # generate Series index if needed by using SeriesType.index (i.e. not self._index)
        na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
        data = self._data[~na_data_arr]
        index = self.index[~na_data_arr]
        return pandas.Series(data, index, self._name)

    return hpat_pandas_series_dropna_impl


@sdc_overload_method(SeriesType, 'fillna')
def hpat_pandas_series_fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
    """
    Pandas Series method :meth:`pandas.Series.fillna` implementation.

    .. only:: developer

       Tests: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_fillna*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    value: scalar of the same dtype as input Series (other types currently unsupported), default None
        Value to use to fill the NA elements
    method: :obj:`string` {`backfill`, `bfill`, `pad`, `ffill`, None}, default None
        Method to use for filling holes in reindexed Series.
        *unsupported*
    axis: :obj:`int` or :obj:`string` {0 or `index`}, default None
        There is only one axis to drop values from.
    inplace: :obj:`bool`, default False
        If True, do operation inplace and return None.
        Supported as literal value only
    limit: :obj:`int`, default None
        If method is specified, this is the maximum number of consecutive NaN
        values to forward/backward fill.
        *unsupported*
    downcast: :obj:`dict` or :obj:`string` {`infer`}, default None
        Controls logic of downcasting elements to particular dtype
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` with missed values filled.
    """

    _func_name = 'Method fillna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.StringLiteral, types.UnicodeType, types.Omitted)) or axis is None):
        raise TypingError('{} The axis must be an Integer or String. Given: {}'.format(_func_name, axis))

    if not (isinstance(inplace, types.Literal) and isinstance(inplace, types.Boolean)
            or isinstance(inplace, types.Omitted)
            or inplace is False):
        raise TypingError('{} The inplace must be a literal Boolean constant. Given: {}'.format(_func_name, inplace))

    if not (
        (method is None or isinstance(method, types.Omitted))
        and (limit is None or isinstance(limit, types.Omitted))
        and (downcast is None or isinstance(downcast, types.Omitted))
    ):
        raise TypingError('{} Unsupported parameters. Given method: {}, limit: {}, downcast: {}'.format(
                _func_name, method, limit, downcast))

    # inplace value has to be known at compile time to select between implementations with different signatures
    if ((isinstance(inplace, types.Literal) and inplace.literal_value == True)
        or (isinstance(inplace, bool) and inplace == True)):
        # do operation inplace, fill the NA/NaNs in the same array and return None
        if isinstance(self.dtype, types.UnicodeType):
            # TODO: StringArrayType cannot resize inplace, and assigning a copy back to self._data is not possible now
            raise TypingError('{} Not implemented when Series dtype is {} and\
                 inplace={}'.format(_func_name, self.dtype, inplace))

        elif isinstance(self.dtype, (types.Integer, types.Boolean)):
            def hpat_pandas_series_no_nan_fillna_impl(self, value=None, method=None, axis=None, inplace=False,
                                                      limit=None, downcast=None):
                # no NaNs in series of Integers or Booleans
                return None

            return hpat_pandas_series_no_nan_fillna_impl
        else:
            def hpat_pandas_series_fillna_impl(self, value=None, method=None, axis=None, inplace=False,
                                               limit=None, downcast=None):
                na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
                self._data[na_data_arr] = value
                return None

            return hpat_pandas_series_fillna_impl
    else:
        # non inplace implementations, copy array, fill the NA/NaN and return a new Series
        if isinstance(self.dtype, types.UnicodeType):
            # For StringArrayType implementation is taken from _series_fillna_str_alloc_impl
            # (can be called directly when it's index handling is fixed)
            def hpat_pandas_series_str_fillna_impl(self, value=None, method=None, axis=None,
                                                   inplace=False, limit=None, downcast=None):

                n = len(self._data)
                num_chars = 0
                # get total chars in new array
                for i in numba.parfor.internal_prange(n):
                    s = self._data[i]
                    if sdc.hiframes.api.isna(self._data, i):
                        num_chars += len(value)
                    else:
                        num_chars += len(s)

                filled_data = sdc.str_arr_ext.pre_alloc_string_array(n, num_chars)
                for i in numba.parfor.internal_prange(n):
                    if sdc.hiframes.api.isna(self._data, i):
                        filled_data[i] = value
                    else:
                        filled_data[i] = self._data[i]
                return pandas.Series(filled_data, self._index, self._name)

            return hpat_pandas_series_str_fillna_impl

        elif isinstance(self.dtype, (types.Integer, types.Boolean)):
            def hpat_pandas_series_no_nan_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                return pandas.Series(numpy.copy(self._data), self._index, self._name)

            return hpat_pandas_series_no_nan_fillna_impl

        else:
            def hpat_pandas_series_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
                filled_data = numpy.copy(self._data)
                filled_data[na_data_arr] = value
                return pandas.Series(filled_data, self._index, self._name)

            return hpat_pandas_series_fillna_impl


@sdc_overload_method(SeriesType, 'cov')
def hpat_pandas_series_cov(self, other, min_periods=None):
    """
    Pandas Series method :meth:`pandas.Series.cov` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_cov

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    other: :obj:`pandas.Series`
        input series
    min_periods: :obj:`int`, default None

    Returns
    -------
    :obj:`float`
         returns :obj:`float` object
    """

    ty_checker = TypeChecker('Method cov().')
    ty_checker.check(self, SeriesType)

    ty_checker.check(other, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data.dtype, 'number', 'self.data')

    if not isinstance(other.data.dtype, types.Number):
        ty_checker.raise_exc(other.data.dtype, 'number', 'other.data')

    if not isinstance(min_periods, (types.Integer, types.Omitted, types.NoneType)) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'int64', 'min_periods')

    def hpat_pandas_series_cov_impl(self, other, min_periods=None):

        if min_periods is None:
            min_periods = 1

        if len(self._data) == 0 or len(other._data) == 0:
            return numpy.nan

        self_arr = self._data[:min(len(self._data), len(other._data))]
        other_arr = other._data[:min(len(self._data), len(other._data))]

        invalid = numpy.isnan(self_arr) | numpy.isnan(other_arr)
        if invalid.any():
            self_arr = self_arr[~invalid]
            other_arr = other_arr[~invalid]

        if len(self_arr) < min_periods:
            return numpy.nan

        new_self = pandas.Series(self_arr)

        ma = new_self.mean()
        mb = other.mean()

        if numpy.isinf(mb):
            return numpy.nan

        return ((self_arr - ma) * (other_arr - mb)).sum() / (new_self.count() - 1.0)

    return hpat_pandas_series_cov_impl


@sdc_overload_method(SeriesType, 'pct_change')
def hpat_pandas_series_pct_change(self, periods=1, fill_method='pad', limit=None, freq=None):
    """
    Pandas Series method :meth:`pandas.Series.pct_change` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_pct_change

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    periods: :obj:`int`, default 1
        Periods to shift for forming percent change.
    fill_method: :obj:`str`, default 'pad'
        How to handle NAs before computing percent changes.
    limit: :obj:`int`, default Nogne
        The number of consecutive NAs to fill before stopping.
        *unsupported*
    freq: :obj: DateOffset, timedelta, or offset alias string, optional
        Increment to use from time series API (e.g. 'M' or BDay()).
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method pct_change().')
    ty_checker.check(self, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data.dtype, 'number', 'self.data')

    if not isinstance(periods, (types.Integer, types.Omitted)):
        ty_checker.raise_exc(periods, 'int64', 'periods')

    if not isinstance(fill_method, (str, types.UnicodeType, types.StringLiteral, types.NoneType, types.Omitted)):
        ty_checker.raise_exc(fill_method, 'string', 'fill_method')

    if not isinstance(limit, (types.Omitted, types.NoneType)):
        ty_checker.raise_exc(limit, 'None', 'limit')

    if not isinstance(freq, (types.Omitted, types.NoneType)):
        ty_checker.raise_exc(freq, 'None', 'freq')

    def hpat_pandas_series_pct_change_impl(self, periods=1, fill_method='pad', limit=None, freq=None):
        if not (fill_method is None or fill_method in ['pad', 'ffill', 'backfill', 'bfill']):
            raise ValueError(
                "Method pct_change(). Unsupported parameter. The function uses fill_method pad (ffill) or backfill (bfill) or None.")
        local_series = self.copy()
        if fill_method is not None:
            # replacement method fillna for given method
            # =========================================
            # Example:
            # s = [1.1, 0.3, np.nan, 1, np.inf, 0, 1.1, np.nan, 2.2, np.inf, 2, 2]
            # result = [1.1, 0.3, 0.3, 1, inf, 0, 1.1, 1.1, 2.2, inf, 2, 2]
            # ==========================================
            for i in range(len(local_series._data)):
                # check each element on numpy.nan
                if numpy.isnan(local_series._data[i]):
                    if fill_method in ['pad', 'ffill']:
                        # if it first element is nan, element will be is nan
                        # if it not first element, element will be is nearest is not nan element
                        # take a step back while will not find is not nan element
                        # if before the first element you did not find one, the element will be equal nan
                        if i == 0:
                            local_series._data[i] = numpy.nan
                        else:
                            k = 1
                            while numpy.isnan(local_series._data[i - k]):
                                if i - k == 0:
                                    local_series._data[i] = numpy.nan
                                    break
                                k += 1
                            local_series._data[i] = local_series._data[i - k]
                    elif fill_method in ['backfill', 'bfill']:
                        # if it last element is nan, element will be is nan
                        # if it not last element, element will be is nearest is not nan element
                        # take a step front while will not find is not nan element
                        # if before the last element you did not find one, the element will be equal nan
                        if i == len(local_series._data)-1:
                            local_series._data[i] = numpy.nan
                        else:
                            k = 1
                            while numpy.isnan(local_series._data[i + k]):
                                if i + k == len(local_series._data) - 1:
                                    local_series._data[i] = numpy.nan
                                    break
                                k += 1
                            local_series._data[i] = local_series._data[i + k]
        rshift = local_series.shift(periods=periods, freq=freq)
        rdiv = local_series.div(rshift)
        result = rdiv._data - 1
        return pandas.Series(result)

    return hpat_pandas_series_pct_change_impl
