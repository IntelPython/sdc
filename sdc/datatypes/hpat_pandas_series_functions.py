# *****************************************************************************
# Copyright (c) 2019, Intel Corporation All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#     Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# *****************************************************************************

"""
| :class:`pandas.Series` functions and operators implementations in SDC
| Also, it contains Numba internal operators which are required for Series type handling
"""

import numba
import numpy
import operator
import pandas

from numba.errors import TypingError
from numba.extending import overload, overload_method, overload_attribute
from numba import (types, numpy_support)
from numba.typed import Dict

import sdc
import sdc.datatypes.common_functions as common_functions
from sdc.datatypes.common_functions import (TypeChecker, check_index_is_numeric, find_common_dtype_from_numpy_dtypes,
                                            sdc_join_series_indexes)
from sdc.datatypes.hpat_pandas_series_rolling_types import _hpat_pandas_series_rolling_init
from sdc.datatypes.hpat_pandas_stringmethods_types import StringMethodsType
from sdc.hiframes.pd_series_ext import SeriesType
from sdc.str_arr_ext import (StringArrayType, string_array_type, str_arr_is_na, str_arr_set_na,
                             num_total_chars, pre_alloc_string_array, cp_str_list_to_array)
from sdc.utils import to_array, sdc_overload, sdc_overload_method, sdc_overload_attribute
from sdc.datatypes import hpat_pandas_series_autogenerated


@sdc_overload(operator.getitem)
def hpat_pandas_series_getitem(self, idx):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.get

    Limitations
    -----------
    Supported ``key`` can be one of the following:
        - Integer scalar, e.g. :obj:`series[0]`
        - A slice, e.g. :obj:`series[2:5]`
        - Another series

    Examples
    --------
    .. literalinclude:: ../../../examples/series_getitem.py
       :language: python
       :lines: 27-
       :caption: Getting Pandas Series elements
       :name: ex_series_getitem

    .. command-output:: python ./series_getitem.py
       :cwd: ../../../examples

    .. todo:: Fix SDC behavior and add the expected output of the > python ./series_getitem.py to the docstring

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series operator :attr:`pandas.Series.get` implementation
    **Algorithm**: result = series[idx]

    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_static_getitem_series1

    Parameters
    ----------
    series: :obj:`pandas.Series`
           input series
    idx: :obj:`int`, :obj:`slice` or :obj:`pandas.Series`
        input index

    Returns
    -------
    :class:`pandas.Series` or an element of the underneath type
            object of :class:`pandas.Series`
    """

    _func_name = 'Operator getitem().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(idx, types.Integer):
        def hpat_pandas_series_getitem_idx_integer_impl(self, idx):
            """
            **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_iloc1
            """

            result = self._data[idx]
            return result

        return hpat_pandas_series_getitem_idx_integer_impl

    if isinstance(idx, types.SliceType):
        def hpat_pandas_series_getitem_idx_slice_impl(self, idx):
            """
            **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_iloc2
            """

            result = pandas.Series(self._data[idx])
            return result

        return hpat_pandas_series_getitem_idx_slice_impl

    if isinstance(idx, SeriesType):
        def hpat_pandas_series_getitem_idx_series_impl(self, idx):
            """
            **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_setitem_series_bool2
            """
            super_index = idx._data
            result = self._data[super_index]
            return result

        return hpat_pandas_series_getitem_idx_series_impl

    raise TypingError('{} The index must be an Integer, Slice or a pandas.series. Given: {}'.format(_func_name, idx))


@sdc_overload(operator.setitem)
def hpat_pandas_series_setitem(self, idx, value):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.set

    Examples
    --------
    .. literalinclude:: ../../../examples/series_setitem_int.py
       :language: python
       :lines: 27-
       :caption: Setting Pandas Series elements
       :name: ex_series_setitem

    .. code-block:: console

        > python ./series_setitem_int.py

            0    0
            1    4
            2    3
            3    2
            4    1
            dtype: int64

        > python ./series_setitem_slice.py

            0    5
            1    4
            2    0
            3    0
            4    0
            dtype: int64

        > python ./series_setitem_series.py

            0    5
            1    0
            2    3
            3    0
            4    1
            dtype: int64

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
     Pandas Series operator :attr:`pandas.Series.set` implementation

    Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_setitem*

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series
    idx: :obj:`int`, :obj:`slice` or :obj:`pandas.Series`
        input index
    value: :object
        input value

    Returns
    -------
    :class:`pandas.Series` or an element of the underneath type
            object of :class:`pandas.Series`
    """

    ty_checker = TypeChecker('Operator setitem.')
    ty_checker.check(self, SeriesType)

    if not (isinstance(idx, (types.Integer, types.SliceType, SeriesType))):
        ty_checker.raise_exc(idx, 'int, Slice, Series', 'idx')

    if not((isinstance(value, SeriesType) and isinstance(value.dtype, self.dtype)) or \
           isinstance(value, type(self.dtype))):
        ty_checker.raise_exc(value, self.dtype, 'value')

    if isinstance(idx, types.Integer) or isinstance(idx, types.SliceType):
        def hpat_pandas_series_setitem_idx_integer_impl(self, idx, value):
            """
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_value
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_slice
            """
            self._data[idx] = value
            return self

        return hpat_pandas_series_setitem_idx_integer_impl

    if isinstance(idx, SeriesType):
        def hpat_pandas_series_setitem_idx_series_impl(self, idx, value):
            """
            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_setitem_for_series
            """
            super_index = idx._data
            self._data[super_index] = value
            return self

        return hpat_pandas_series_setitem_idx_series_impl


@sdc_overload_attribute(SeriesType, 'at')
@sdc_overload_attribute(SeriesType, 'iat')
@sdc_overload_attribute(SeriesType, 'iloc')
@sdc_overload_attribute(SeriesType, 'loc')
def hpat_pandas_series_iloc(self):
    """
    Pandas Series operators :attr:`pandas.Series.at`, :attr:`pandas.Series.iat`, :attr:`pandas.Series.iloc`, :attr:`pandas.Series.loc` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_iloc2

    Parameters
    ----------
    series: :class:`pandas.Series`
           input series

    Returns
    -------
    :obj:`pandas.Series`
         returns an object of :obj:`pandas.Series`
    """

    _func_name = 'Operator at/iat/iloc/loc().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_iloc_impl(self):
        return self

    return hpat_pandas_series_iloc_impl


@sdc_overload_method(SeriesType, 'nsmallest')
def hpat_pandas_series_nsmallest(self, n=5, keep='first'):
    """
    Pandas Series method :meth:`pandas.Series.nsmallest` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_nsmallest*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    n: :obj:`int`, default 5
        Return this many ascending sorted values.
    keep: :obj:`str`, default 'first'
        When there are duplicate values that cannot all fit in a Series of n elements:
        first : return the first n occurrences in order of appearance.
        last : return the last n occurrences in reverse order of appearance.
        all : keep all occurrences. This can result in a Series of size larger than n.
        *unsupported*

    Returns
    -------
    :obj:`series`
         returns :obj:`series`
    """

    _func_name = 'Method nsmallest().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object\n given: {}\n expected: {}'.format(_func_name, self, 'series'))

    if not isinstance(n, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object n\n given: {}\n expected: {}'.format(_func_name, n, 'int'))

    if not isinstance(keep, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} The object keep\n given: {}\n expected: {}'.format(_func_name, keep, 'str'))

    def hpat_pandas_series_nsmallest_impl(self, n=5, keep='first'):
        if keep != 'first':
            raise ValueError("Method nsmallest(). Unsupported parameter. Given 'keep' != 'first'")

        # mergesort is used for stable sorting of repeated values
        indices = self._data.argsort(kind='mergesort')[:max(n, 0)]

        return self.take(indices)

    return hpat_pandas_series_nsmallest_impl


@sdc_overload_method(SeriesType, 'nlargest')
def hpat_pandas_series_nlargest(self, n=5, keep='first'):
    """
    Pandas Series method :meth:`pandas.Series.nlargest` implementation.

    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_nlargest*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    n: :obj:`int`, default 5
        Return this many ascending sorted values.
    keep: :obj:`str`, default 'first'
        When there are duplicate values that cannot all fit in a Series of n elements:
        first : return the first n occurrences in order of appearance.
        last : return the last n occurrences in reverse order of appearance.
        all : keep all occurrences. This can result in a Series of size larger than n.
        *unsupported*

    Returns
    -------
    :obj:`series`
         returns :obj:`series`
    """

    _func_name = 'Method nlargest().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object\n given: {}\n expected: {}'.format(_func_name, self, 'series'))

    if not isinstance(n, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object n\n given: {}\n expected: {}'.format(_func_name, n, 'int'))

    if not isinstance(keep, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} The object keep\n given: {}\n expected: {}'.format(_func_name, keep, 'str'))

    def hpat_pandas_series_nlargest_impl(self, n=5, keep='first'):
        if keep != 'first':
            raise ValueError("Method nlargest(). Unsupported parameter. Given 'keep' != 'first'")

        # data: [0, 1, -1, 1, 0] -> [1, 1, 0, 0, -1]
        # index: [0, 1,  2, 3, 4] -> [1, 3, 0, 4,  2] (not [3, 1, 4, 0, 2])
        # subtract 1 to ensure reverse ordering at boundaries
        indices = (-self._data - 1).argsort(kind='mergesort')[:max(n, 0)]

        return self.take(indices)

    return hpat_pandas_series_nlargest_impl


@sdc_overload_attribute(SeriesType, 'shape')
def hpat_pandas_series_shape(self):
    """
    Pandas Series attribute :attr:`pandas.Series.shape` implementation
    **Algorithm**: result = series.shape
    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shape1
    Parameters
    ----------
    series: :obj:`pandas.Series`
          input series
    Returns
    -------
    :obj:`tuple`
        a tuple of the shape of the underlying data
    """

    _func_name = 'Attribute shape.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_shape_impl(self):
        return self._data.shape

    return hpat_pandas_series_shape_impl


@sdc_overload_method(SeriesType, 'std')
def hpat_pandas_series_std(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.std` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_std_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    level: :obj:`int`, :obj:`str`
        If the axis is a MultiIndex (hierarchical),
        count along a particular level, collapsing into a scalar
        *unsupported*
    ddof: :obj:`int`
        Delta Degrees of Freedom.
        The divisor used in calculations is N - ddof,
        where N represents the number of elements.
    numeric_only: :obj:`bool`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:`scalar`
         returns :obj:`scalar`
    """

    _func_name = 'Method std().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean, types.NoneType)) and skipna is not None:
        raise TypingError('{} The object must be a boolean. Given skipna: {}'.format(_func_name, skipna))

    if not isinstance(ddof, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object must be an integer. Given ddof: {}'.format(_func_name, ddof))

    for name, arg in [('axis', axis), ('level', level), ('numeric_only', numeric_only)]:
        if not isinstance(arg, (types.Omitted, types.NoneType)) and arg is not None:
            raise TypingError('{} Unsupported parameters. Given {}: {}'.format(_func_name, name, arg))

    def hpat_pandas_series_std_impl(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
        var = self.var(axis=axis, skipna=skipna, level=level, ddof=ddof, numeric_only=numeric_only)
        return var ** 0.5

    return hpat_pandas_series_std_impl


@sdc_overload_attribute(SeriesType, 'values')
def hpat_pandas_series_values(self):
    """
    Pandas Series attribute 'values' implementation.
        https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.values.html#pandas.Series.values
    Algorithm: result = series.values
    Where:
        series: pandas.series
        result: pandas.series as ndarray
    Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_values
    """

    _func_name = 'Attribute values.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_values_impl(self):
        return self._data

    return hpat_pandas_series_values_impl


@sdc_overload_method(SeriesType, 'value_counts')
def hpat_pandas_series_value_counts(self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.value_counts

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_value_counts.py
       :language: python
       :lines: 27-
       :caption: Getting the number of values excluding NaNs
       :name: ex_series_value_counts

    .. command-output:: python ./series/series_value_counts.py
       :cwd: ../../../examples

     .. note::

        Parameter bins and dropna for Strings are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.count <pandas.Series.count>`


    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.value_counts` implementation.

    Note: Elements with the same count might appear in result in a different order than in Pandas

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_value_counts*

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    normalize: :obj:`boolean`, default False
        If True then the object returned will contain the relative frequencies of the unique values
    sort: :obj: `boolean`, default True
        Sort by frequencies
    ascending: :obj:`boolean`, default False
        Sort in ascending order
    bins: :obj:`integer`, default None
        *unsupported*
    dropna: :obj:`boolean`, default True
        Skip counts of NaN

    Returns
    -------
    :returns :obj:`pandas.Series`
    """

    _func_name = 'Method value_counts().'

    ty_checker = TypeChecker('Method value_counts().')
    ty_checker.check(self, SeriesType)

    if not isinstance(normalize, (types.Omitted, types.Boolean, bool)) and normalize is True:
        ty_checker.raise_exc(normalize, 'boolean', 'normalize')

    if not isinstance(sort, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(sort, 'boolean', 'sort')

    if not isinstance(ascending, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(ascending, 'boolean', 'ascending')

    if not isinstance(bins, (types.Omitted, types.NoneType)) and bins is not None:
        ty_checker.raise_exc(bins, 'boolean', 'bins')

    if not isinstance(dropna, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(dropna, 'boolean', 'dropna')

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_value_counts_str_impl(
                self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):

            value_counts_dict = Dict.empty(
                key_type=types.unicode_type,
                value_type=types.intp
            )

            nan_counts = 0
            for i, value in enumerate(self._data):
                if str_arr_is_na(self._data, i):
                    if not dropna:
                        nan_counts += 1
                    continue

                value_counts_dict[value] = value_counts_dict.get(value, 0) + 1

            need_add_nan_count = not dropna and nan_counts

            values = [key for key in value_counts_dict]
            counts_as_list = [value_counts_dict[key] for key in value_counts_dict.keys()]
            values_len = len(values)

            if need_add_nan_count:
                # append a separate empty string for NaN elements
                values_len += 1
                values.append('')
                counts_as_list.append(nan_counts)

            counts = numpy.asarray(counts_as_list, dtype=numpy.intp)
            indexes_order = numpy.arange(values_len)
            if sort:
                indexes_order = counts.argsort()
                if not ascending:
                    indexes_order = indexes_order[::-1]

            counts_sorted = numpy.take(counts, indexes_order)
            values_sorted_by_count = [values[i] for i in indexes_order]

            # allocate the result index as a StringArray and copy values to it
            index_string_lengths = numpy.asarray([len(s) for s in values_sorted_by_count])
            index_total_chars = numpy.sum(index_string_lengths)
            result_index = pre_alloc_string_array(len(values_sorted_by_count), index_total_chars)
            cp_str_list_to_array(result_index, values_sorted_by_count)

            if need_add_nan_count:
                # set null bit for StringArray element corresponding to NaN element (was added as last in values)
                index_previous_nan_pos = values_len - 1
                for i in numpy.arange(values_len):
                    if indexes_order[i] == index_previous_nan_pos:
                        str_arr_set_na(result_index, i)
                        break

            return pandas.Series(counts_sorted, index=result_index, name=self._name)

        return hpat_pandas_series_value_counts_str_impl

    elif isinstance(self.dtype, types.Number):

        series_dtype = self.dtype
        def hpat_pandas_series_value_counts_number_impl(
                self, normalize=False, sort=True, ascending=False, bins=None, dropna=True):

            value_counts_dict = Dict.empty(
                key_type=series_dtype,
                value_type=types.intp
            )

            zero_counts = 0
            is_zero_found = False
            for value in self._data:
                if (dropna and numpy.isnan(value)):
                    continue

                # Pandas hash-based value_count_float64 function doesn't distinguish between
                # positive and negative zeros, hence we count zero values separately and store
                # as a key the first zero value found in the Series
                if not value:
                    zero_counts += 1
                    if not is_zero_found:
                        zero_value = value
                        is_zero_found = True
                    continue

                value_counts_dict[value] = value_counts_dict.get(value, 0) + 1

            if zero_counts:
                value_counts_dict[zero_value] = zero_counts

            unique_values = numpy.asarray(
                list(value_counts_dict),
                dtype=self._data.dtype
            )
            value_counts = numpy.asarray(
                [value_counts_dict[key] for key in value_counts_dict],
                dtype=numpy.intp
            )

            indexes_order = numpy.arange(len(value_counts))
            if sort:
                indexes_order = value_counts.argsort()
                if not ascending:
                    indexes_order = indexes_order[::-1]

            sorted_unique_values = numpy.take(unique_values, indexes_order)
            sorted_value_counts = numpy.take(value_counts, indexes_order)

            return pandas.Series(sorted_value_counts, index=sorted_unique_values, name=self._name)

        return hpat_pandas_series_value_counts_number_impl

    return None


@sdc_overload_method(SeriesType, 'var')
def hpat_pandas_series_var(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.var` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_var_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    level: :obj:`int`, :obj:`str`
        If the axis is a MultiIndex (hierarchical),
        count along a particular level, collapsing into a scalar
        *unsupported*
    ddof: :obj:`int`
        Delta Degrees of Freedom.
        The divisor used in calculations is N - ddof,
        where N represents the number of elements.
    numeric_only: :obj:`bool`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:`scalar`
         returns :obj:`scalar`
    """

    _func_name = 'Method var().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean, types.NoneType)) and skipna is not None:
        raise TypingError('{} The object must be a boolean. Given skipna: {}'.format(_func_name, skipna))

    if not isinstance(ddof, (types.Omitted, int, types.Integer)):
        raise TypingError('{} The object must be an integer. Given ddof: {}'.format(_func_name, ddof))

    for name, arg in [('axis', axis), ('level', level), ('numeric_only', numeric_only)]:
        if not isinstance(arg, (types.Omitted, types.NoneType)) and arg is not None:
            raise TypingError('{} Unsupported parameters. Given {}: {}'.format(_func_name, name, arg))

    def hpat_pandas_series_var_impl(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None):
        if skipna is None:
            skipna = True

        if skipna:
            valuable_length = len(self._data) - numpy.sum(numpy.isnan(self._data))
            if valuable_length <= ddof:
                return numpy.nan

            return numpy.nanvar(self._data) * valuable_length / (valuable_length - ddof)

        if len(self._data) <= ddof:
            return numpy.nan

        return self._data.var() * len(self._data) / (len(self._data) - ddof)

    return hpat_pandas_series_var_impl


@sdc_overload_attribute(SeriesType, 'index')
def hpat_pandas_series_index(self):
    """
    Pandas Series attribute :attr:`pandas.Series.index` implementation
    **Algorithm**: result = series.index
    **Test**: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_index1
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_index2
    Parameters
    ----------
    series: :obj:`pandas.Series`
           input series
    Returns
    -------
    :class:`pandas.Series`
           the index of the Series
    """

    _func_name = 'Attribute index.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_index_none_impl(self):
            return numpy.arange(len(self._data))

        return hpat_pandas_series_index_none_impl
    else:
        def hpat_pandas_series_index_impl(self):
            return self._index

        return hpat_pandas_series_index_impl


@sdc_overload_method(SeriesType, 'rolling')
def hpat_pandas_series_rolling(self, window, min_periods=None, center=False,
                               win_type=None, on=None, axis=0, closed=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************
    Pandas API: pandas.Series.rolling

    Examples
    --------
    .. literalinclude:: ../../../examples/series/rolling/series_rolling_min.py
       :language: python
       :lines: 27-
       :caption: Calculate the rolling minimum.
       :name: ex_series_rolling

    .. command-output:: python ./series/rolling/series_rolling_min.py
       :cwd: ../../../examples

    .. todo:: Add support of parameters ``center``, ``win_type``, ``on``, ``axis`` and ``closed``

    .. seealso::
        :ref:`expanding <pandas.Series.expanding>`
            Provides expanding transformations.
        :ref:`ewm <pandas.Series.ewm>`
            Provides exponential weighted functions.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series attribute :attr:`pandas.Series.rolling` implementation
    .. only:: developer

    Test: python -m sdc.runtests -k sdc.tests.test_rolling.TestRolling.test_series_rolling

    Parameters
    ----------
    series: :obj:`pandas.Series`
        Input Series.
    window: :obj:`int` or :obj:`offset`
        Size of the moving window.
    min_periods: :obj:`int`
        Minimum number of observations in window required to have a value.
    center: :obj:`bool`
        Set the labels at the center of the window.
        *unsupported*
    win_type: :obj:`str`
        Provide a window type.
        *unsupported*
    on: :obj:`str`
        Column on which to calculate the rolling window.
        *unsupported*
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    closed: :obj:`str`
        Make the interval closed on the ‘right’, ‘left’, ‘both’ or ‘neither’ endpoints.
        *unsupported*

    Returns
    -------
    :class:`pandas.Series.rolling`
        Output class to manipulate with input data.
    """

    ty_checker = TypeChecker('Method rolling().')
    ty_checker.check(self, SeriesType)

    if not isinstance(window, types.Integer):
        ty_checker.raise_exc(window, 'int', 'window')

    minp_accepted = (types.Omitted, types.NoneType, types.Integer)
    if not isinstance(min_periods, minp_accepted) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'None, int', 'min_periods')

    center_accepted = (types.Omitted, types.Boolean)
    if not isinstance(center, center_accepted) and center is not False:
        ty_checker.raise_exc(center, 'bool', 'center')

    str_types = (types.Omitted, types.NoneType, types.StringLiteral, types.UnicodeType)
    if not isinstance(win_type, str_types) and win_type is not None:
        ty_checker.raise_exc(win_type, 'str', 'win_type')

    if not isinstance(on, str_types) and on is not None:
        ty_checker.raise_exc(on, 'str', 'on')

    axis_accepted = (types.Omitted, types.Integer, types.StringLiteral, types.UnicodeType)
    if not isinstance(axis, axis_accepted) and axis != 0:
        ty_checker.raise_exc(axis, 'int, str', 'axis')

    if not isinstance(closed, str_types) and closed is not None:
        ty_checker.raise_exc(closed, 'str', 'closed')

    nan_minp = isinstance(min_periods, (types.Omitted, types.NoneType)) or min_periods is None

    def hpat_pandas_series_rolling_impl(self, window, min_periods=None, center=False,
                                        win_type=None, on=None, axis=0, closed=None):
        if window < 0:
            raise ValueError('window must be non-negative')

        if nan_minp == True:  # noqa
            minp = window
        else:
            minp = min_periods

        if minp < 0:
            raise ValueError('min_periods must be >= 0')
        if minp > window:
            raise ValueError('min_periods must be <= window')

        if center != False:  # noqa
            raise ValueError('Method rolling(). The object center\n expected: False')

        if win_type is not None:
            raise ValueError('Method rolling(). The object win_type\n expected: None')

        if on is not None:
            raise ValueError('Method rolling(). The object on\n expected: None')

        if axis != 0:
            raise ValueError('Method rolling(). The object axis\n expected: 0')

        if closed is not None:
            raise ValueError('Method rolling(). The object closed\n expected: None')

        return _hpat_pandas_series_rolling_init(self, window, minp, center,
                                                win_type, on, axis, closed)

    return hpat_pandas_series_rolling_impl


@sdc_overload_attribute(SeriesType, 'size')
def hpat_pandas_series_size(self):
    """
    Pandas Series attribute :attr:`pandas.Series.size` implementation

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_size

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series

    Returns
    -------
    :class:`pandas.Series`
        Return the number of elements in the underlying data.
    """

    _func_name = 'Attribute size.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_size_impl(self):
        return len(self._data)

    return hpat_pandas_series_size_impl


@sdc_overload_attribute(SeriesType, 'str')
def hpat_pandas_series_str(self):
    """
    Pandas Series attribute :attr:`pandas.Series.str` implementation

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_hiframes.TestHiFrames.test_str_get

    Parameters
    ----------
    series: :obj:`pandas.Series`
        input series

    Returns
    -------
    :class:`pandas.core.strings.StringMethods`
        Output class to manipulate with input data.
    """

    _func_name = 'Attribute str.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.List, types.UnicodeType)):
        msg = '{}  Can only use .str accessor with string values. Given: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    def hpat_pandas_series_str_impl(self):
        return pandas.core.strings.StringMethods(self)

    return hpat_pandas_series_str_impl


@sdc_overload_attribute(SeriesType, 'ndim')
def hpat_pandas_series_ndim(self):
    """
    Pandas Series attribute :attr:`pandas.Series.ndim` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_getattr_ndim

    Parameters
    ----------
    self: :obj:`pandas.Series`
           input series

    Returns
    -------
    :obj:`int`
           Number of dimensions of the underlying data, by definition 1
    """

    _func_name = 'Attribute ndim.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_ndim_impl(self):
        return 1

    return hpat_pandas_series_ndim_impl


@sdc_overload_attribute(SeriesType, 'T')
def hpat_pandas_series_T(self):
    """
    Pandas Series attribute :attr:`pandas.Series.T` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_getattr_T

    Parameters
    ----------
    self: :obj:`pandas.Series`
           input series

    Returns
    -------
    :obj:`numpy.ndarray`
         An array representing the underlying data
    """

    _func_name = 'Attribute T.'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_T_impl(self):
        return self._data

    return hpat_pandas_series_T_impl


@sdc_overload(len)
def hpat_pandas_series_len(self):
    """
    Pandas Series operator :func:`len` implementation

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_len

    Parameters
    ----------
    series: :class:`pandas.Series`

    Returns
    -------
    :obj:`int`
        number of items in the object
    """

    _func_name = 'Operator len().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    def hpat_pandas_series_len_impl(self):
        return len(self._data)

    return hpat_pandas_series_len_impl


@sdc_overload_method(SeriesType, 'astype')
def hpat_pandas_series_astype(self, dtype, copy=True, errors='raise'):
    """
    Pandas Series method :meth:`pandas.Series.astype` implementation.
    Cast a pandas object to a specified dtype dtype
    .. only:: developer
        Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_astype*

    Parameters
    -----------
    dtype : :obj:`numpy.dtype` or :obj:`dict`
               Use a numpy.dtype or Python type to cast entire pandas object to the same type.
               Alternatively, use {col: dtype, …}, where col is a column label and dtype is a numpy.dtype
               or Python type to cast one or more of the DataFrame’s columns to column-specific types.

    copy : :obj:`bool`, default :obj:`True`
            Return a copy when True
            Currently copy=False is not supported
    errors : :obj:`str`, default :obj:`'raise'`
            Control raising of exceptions on invalid data for provided dtype.
                * raise : allow exceptions to be raised
                * ignore : suppress exceptions. On error return original object
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` Cast a :obj:`pandas.Series` to a specified dtype dtype
    """

    _func_name = 'Method astype().'
    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(copy, (types.Omitted, bool, types.Boolean)):
        raise TypingError('{} The object must be a boolean. Given copy: {}'.format(_func_name, copy))

    if (not isinstance(errors, (types.Omitted, str, types.UnicodeType, types.StringLiteral)) and
        errors in ('raise', 'ignore')):
        raise TypingError('{} The object must be a string literal. Given errors: {}'.format(_func_name, errors))

    # Return StringArray for astype(str) or astype('str')
    def hpat_pandas_series_astype_to_str_impl(self, dtype, copy=True, errors='raise'):
        num_chars = 0
        arr_len = len(self._data)

        # Get total chars for new array
        for i in numba.parfor.internal_prange(arr_len):
            item = self._data[i]
            num_chars += len(str(item))  # TODO: check NA

        data = sdc.str_arr_ext.pre_alloc_string_array(arr_len, num_chars)
        for i in numba.parfor.internal_prange(arr_len):
            item = self._data[i]
            data[i] = str(item)  # TODO: check NA

        return pandas.Series(data, self._index, self._name)

    # Return npytypes.Array from npytypes.Array for astype(types.functions.NumberClass), example - astype(np.int64)
    def hpat_pandas_series_astype_numba_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data.astype(dtype), self._index, self._name)

    # Return npytypes.Array from npytypes.Array for astype(types.StringLiteral), example - astype('int64')
    def hpat_pandas_series_astype_literal_type_numba_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data.astype(numpy.dtype(dtype)), self._index, self._name)

    # Return self
    def hpat_pandas_series_astype_no_modify_impl(self, dtype, copy=True, errors='raise'):
        return pandas.Series(self._data, self._index, self._name)


    if ((isinstance(dtype, types.Function) and dtype.typing_key == str)
        or (isinstance(dtype, types.StringLiteral) and dtype.literal_value == 'str')):
        return hpat_pandas_series_astype_to_str_impl

    # Needs Numba astype impl support converting unicode_type to NumberClass and other types
    if isinstance(self.data, StringArrayType):
        if isinstance(dtype, types.functions.NumberClass) and errors == 'raise':
            raise TypingError(f'Needs Numba astype impl support converting unicode_type to {dtype}')
        if isinstance(dtype, types.StringLiteral) and errors == 'raise':
            try:
                literal_value = numpy.dtype(dtype.literal_value)
            except:
                pass # Will raise the exception later
            else:
                raise TypingError(f'Needs Numba astype impl support converting unicode_type to {dtype.literal_value}')

    if isinstance(self.data, types.npytypes.Array) and isinstance(dtype, types.functions.NumberClass):
        return hpat_pandas_series_astype_numba_impl

    if isinstance(self.data, types.npytypes.Array) and isinstance(dtype, types.StringLiteral):
        try:
            literal_value = numpy.dtype(dtype.literal_value)
        except:
            pass # Will raise the exception later
        else:
            return hpat_pandas_series_astype_literal_type_numba_impl

    # Raise error if dtype is not supported
    if errors == 'raise':
        raise TypingError(f'{_func_name} The object must be a supported type. Given dtype: {dtype}')
    else:
        return hpat_pandas_series_astype_no_modify_impl


@sdc_overload_method(SeriesType, 'shift')
def hpat_pandas_series_shift(self, periods=1, freq=None, axis=0, fill_value=None):
    """
    Pandas Series method :meth:`pandas.Series.shift` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_full
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_fill_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_shift_unsupported_params

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    periods: :obj:`int`
        Number of periods to shift. Can be positive or negative.
    freq: :obj:`DateOffset`, :obj:`tseries.offsets`, :obj:`timedelta`, :obj:`str`
        Offset to use from the tseries module or time rule (e.g. ‘EOM’).
        *unsupported*
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    fill_value : :obj:`int`, :obj:`float`
        The scalar value to use for newly introduced missing values.

    Returns
    -------
    :obj:`scalar`
         returns :obj:`series` object
    """

    _func_name = 'Method shift().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(fill_value, (types.Omitted, types.Number, types.NoneType)) and fill_value is not None:
        raise TypingError('{} The object must be a number. Given fill_value: {}'.format(_func_name, fill_value))

    if not isinstance(freq, (types.Omitted, types.NoneType)) and freq is not None:
        raise TypingError('{} Unsupported parameters. Given freq: {}'.format(_func_name, freq))

    if not isinstance(axis, (types.Omitted, int, types.Integer)) and not axis:
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    fill_is_default = isinstance(fill_value, (types.Omitted, types.NoneType)) or fill_value is None
    series_np_dtype = [numpy_support.as_dtype(self.data.dtype)]
    fill_np_dtype = [numpy.float64 if fill_is_default else numpy_support.as_dtype(fill_value)]

    fill_dtype = types.float64 if fill_is_default else fill_value
    common_dtype = find_common_dtype_from_numpy_dtypes([], [self.data.dtype, fill_dtype])

    if fill_is_default:
        def hpat_pandas_series_shift_impl(self, periods=1, freq=None, axis=0, fill_value=None):
            if axis != 0:
                raise TypingError('Method shift(). Unsupported parameters. Given axis != 0')

            arr = numpy.empty(shape=len(self._data), dtype=common_dtype)
            if periods > 0:
                arr[:periods] = numpy.nan
                arr[periods:] = self._data[:-periods]
            elif periods < 0:
                arr[periods:] = numpy.nan
                arr[:periods] = self._data[-periods:]
            else:
                arr[:] = self._data

            return pandas.Series(data=arr, index=self._index, name=self._name)

        return hpat_pandas_series_shift_impl

    def hpat_pandas_series_shift_impl(self, periods=1, freq=None, axis=0, fill_value=None):
        if axis != 0:
            raise TypingError('Method shift(). Unsupported parameters. Given axis != 0')

        arr = numpy.empty(len(self._data), dtype=common_dtype)
        if periods > 0:
            arr[:periods] = fill_value
            arr[periods:] = self._data[:-periods]
        elif periods < 0:
            arr[periods:] = fill_value
            arr[:periods] = self._data[-periods:]
        else:
            arr[:] = self._data

        return pandas.Series(data=arr, index=self._index, name=self._name)

    return hpat_pandas_series_shift_impl


@sdc_overload_method(SeriesType, 'isin')
def hpat_pandas_series_isin(self, values):
    """
    Pandas Series method :meth:`pandas.Series.isin` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isin_list1
    Parameters
    -----------
    values : :obj:`list` or :obj:`set` object
               specifies values to look for in the series
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object indicating if each element of self is in values
    """

    _func_name = 'Method isin().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(values, (types.Set, types.List)):
        raise TypingError(
            '{} The argument must be set or list-like object. Given values: {}'.format(_func_name, values))

    def hpat_pandas_series_isin_impl(self, values):
        # TODO: replace with below line when Numba supports np.isin in nopython mode
        # return pandas.Series(np.isin(self._data, values))
        return pandas.Series(data=[(x in values) for x in self._data], index=self._index, name=self._name)

    return hpat_pandas_series_isin_impl


@sdc_overload_method(SeriesType, 'append')
def hpat_pandas_series_append(self, to_append, ignore_index=False, verify_integrity=False):
    """
    Pandas Series method :meth:`pandas.Series.append` implementation.

    .. only:: developer

        Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_append*

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    to_append : :obj:`pandas.Series` object or :obj:`list` or :obj:`set`
        Series (or list or tuple of Series) to append with self
    ignore_index: :obj:`bool`, default False
        If True, do not use the index labels.
        Supported as literal value only
    verify_integrity: :obj:`bool`, default False
        If True, raise Exception on creating index with duplicates.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
        returns :obj:`pandas.Series` object
        Concatenated Series

    """

    _func_name = 'Method append().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not (isinstance(to_append, SeriesType)
            or (isinstance(to_append, (types.UniTuple, types.List)) and isinstance(to_append.dtype, SeriesType))):
        raise TypingError(
            '{} The argument must be a pandas.series or list/tuple of pandas.series. \
            Given to_append: {}'.format(_func_name, to_append))

    # currently we will always raise this in the end, i.e. if no impl was found
    # TODO: find a way to stop compilation early and not proceed with unliteral step
    if not (isinstance(ignore_index, types.Literal) and isinstance(ignore_index, types.Boolean)
            or isinstance(ignore_index, types.Omitted)
            or ignore_index is False):
        raise TypingError(
            '{} The ignore_index must be a literal Boolean constant. Given: {}'.format(_func_name, ignore_index))

    if not (verify_integrity is False or isinstance(verify_integrity, types.Omitted)):
        raise TypingError(
            '{} Unsupported parameters. Given verify_integrity: {}'.format(_func_name, verify_integrity))

    # ignore_index value has to be known at compile time to select between implementations with different signatures
    ignore_index_is_false = (common_functions.has_literal_value(ignore_index, False)
                             or common_functions.has_python_value(ignore_index, False)
                             or isinstance(ignore_index, types.Omitted))
    to_append_is_series = isinstance(to_append, SeriesType)

    if ignore_index_is_false:
        def hpat_pandas_series_append_impl(self, to_append, ignore_index=False, verify_integrity=False):
            if to_append_is_series == True:  # noqa
                new_data = common_functions.hpat_arrays_append(self._data, to_append._data)
                new_index = common_functions.hpat_arrays_append(self.index, to_append.index)
            else:
                data_arrays_to_append = [series._data for series in to_append]
                index_arrays_to_append = [series.index for series in to_append]
                new_data = common_functions.hpat_arrays_append(self._data, data_arrays_to_append)
                new_index = common_functions.hpat_arrays_append(self.index, index_arrays_to_append)

            return pandas.Series(new_data, new_index)

        return hpat_pandas_series_append_impl

    else:
        def hpat_pandas_series_append_ignore_index_impl(self, to_append, ignore_index=False, verify_integrity=False):

            if to_append_is_series == True:  # noqa
                new_data = common_functions.hpat_arrays_append(self._data, to_append._data)
            else:
                arrays_to_append = [series._data for series in to_append]
                new_data = common_functions.hpat_arrays_append(self._data, arrays_to_append)

            return pandas.Series(new_data, None)

        return hpat_pandas_series_append_ignore_index_impl


@sdc_overload_method(SeriesType, 'copy')
def hpat_pandas_series_copy(self, deep=True):
    """
    Pandas Series method :meth:`pandas.Series.copy` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_str1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_int1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_copy_deep

    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    deep: :obj:`bool`, default :obj:`True`
        Make a deep copy, including a copy of the data and the indices.
        With deep=False neither the indices nor the data are copied.
        [SDC limitations]:
            - deep=False: shallow copy of index is not supported

    Returns
    -------
    :obj:`pandas.Series` or :obj:`pandas.DataFrame`
        Object type matches caller.
    """

    ty_checker = TypeChecker('Method Series.copy().')
    ty_checker.check(self, SeriesType)

    if not isinstance(deep, (types.Omitted, types.Boolean)) and not deep:
        ty_checker.raise_exc(self.data, 'boolean', 'deep')

    if isinstance(self.index, types.NoneType):
        def hpat_pandas_series_copy_impl(self, deep=True):
            if deep:
                return pandas.Series(data=self._data.copy(), name=self._name)
            else:
                return pandas.Series(data=self._data, name=self._name)
        return hpat_pandas_series_copy_impl
    else:
        def hpat_pandas_series_copy_impl(self, deep=True):
            if deep:
                return pandas.Series(data=self._data.copy(), index=self._index.copy(), name=self._name)
            else:
                # Shallow copy of index is not supported yet
                return pandas.Series(data=self._data, index=self._index.copy(), name=self._name)
        return hpat_pandas_series_copy_impl


@sdc_overload_method(SeriesType, 'corr')
def hpat_pandas_series_corr(self, other, method='pearson', min_periods=None):
    """
    Pandas Series method :meth:`pandas.Series.corr` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr_unsupported_dtype
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_corr_unsupported_period

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    other: :obj:`pandas.Series`
        input series
    method:
        *unsupported
    min_periods: :obj:`int`, default None

    Returns
    -------
    :obj:`float`
         returns :obj:`float` object
    """


    ty_checker = TypeChecker('Method corr().')
    ty_checker.check(self, SeriesType)

    ty_checker.check(other, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data, 'number', 'self.data')

    if not isinstance(other.data.dtype, types.Number):
        ty_checker.raise_exc(other.data, 'number', 'other.data')

    if not isinstance(min_periods, (int, types.Integer, types.Omitted, types.NoneType)) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'int64', 'min_periods')

    def hpat_pandas_series_corr_impl(self, other, method='pearson', min_periods=None):

        if min_periods is None:
            min_periods = 1

        if len(self._data) == 0 or len(other._data) == 0:
            return numpy.nan

        self_arr = self._data[:min(len(self._data), len(other._data))]
        other_arr = other._data[:min(len(self._data), len(other._data))]

        invalid = numpy.isnan(self_arr) | numpy.isnan(other_arr)
        if invalid.any():
            self_arr = self_arr[~invalid]
            other_arr = other_arr[~invalid]

        if len(self_arr) < min_periods:
            return numpy.nan

        new_self = pandas.Series(self_arr)
        new_other = pandas.Series(other_arr)

        n = new_self.count()
        ma = new_self.sum()
        mb = new_other.sum()
        a = n * (self_arr * other_arr).sum() - ma * mb
        b1 = n * (self_arr * self_arr).sum() - ma * ma
        b2 = n * (other_arr * other_arr).sum() - mb * mb

        if b1 == 0 or b2 == 0:
            return numpy.nan

        return a / numpy.sqrt(b1 * b2)

    return hpat_pandas_series_corr_impl


@sdc_overload_method(SeriesType, 'head')
def hpat_pandas_series_head(self, n=5):
    """
    Pandas Series method :meth:`pandas.Series.head` implementation.

    .. only:: developer
       Test: python -m -k sdc.runtests sdc.tests.test_series.TestSeries.test_series_head*

    Parameters
    -----------
    n: :obj:`int`, default 5
        input argument, default 5
    Returns
    -------
    :obj:`pandas.Series`
        returns: The first n rows of the caller object.
    """

    _func_name = 'Method head().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(n, (types.Integer, types.Omitted)) and n != 5:
        raise TypingError('{} The parameter must be an integer type. Given type n: {}'.format(_func_name, n))

    if isinstance(self.index, types.NoneType):
        def hpat_pandas_series_head_impl(self, n=5):
            return pandas.Series(data=self._data[:n], name=self._name)

        return hpat_pandas_series_head_impl
    else:
        def hpat_pandas_series_head_index_impl(self, n=5):
            return pandas.Series(data=self._data[:n], index=self._index[:n], name=self._name)

        return hpat_pandas_series_head_index_impl


@sdc_overload_method(SeriesType, 'groupby')
def hpat_pandas_series_groupby(
        self,
        by=None,
        axis=0,
        level=None,
        as_index=True,
        sort=True,
        group_keys=True,
        squeeze=False,
        observed=False):
    """
    Pandas Series method :meth:`pandas.Series.groupby` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_groupby_count
    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    by: :obj:`pandas.Series` object
        Used to determine the groups for the groupby
    axis:
        *unsupported*
    level:
        *unsupported*
    as_index:
        *unsupported*
    sort:
        *unsupported*
    group_keys:
        *unsupported*
    squeeze:
        *unsupported*
    observed:
        *unsupported*
    Returns
    -------
    :obj:`pandas.SeriesGroupBy`
         returns :obj:`pandas.SeriesGroupBy` object
    """

    _func_name = 'Method Series.groupby().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if by is None and axis is None:
        raise TypingError("{} You have to supply one of 'by' or 'axis' parameters".format(_func_name))

    if level is not None and not isinstance(level, (types.Integer, types.NoneType, types.Omitted)):
        raise TypingError("{} 'level' must be an Integer. Given: {}".format(_func_name, level))

    def hpat_pandas_series_groupby_impl(
            self,
            by=None,
            axis=0,
            level=None,
            as_index=True,
            sort=True,
            group_keys=True,
            squeeze=False,
            observed=False):
        # TODO Needs to implement parameters value check
        # if level is not None and (level < -1 or level > 0):
        #     raise ValueError("Method Series.groupby(). level > 0 or level < -1 only valid with MultiIndex")

        return pandas.core.groupby.SeriesGroupBy(self)

    return hpat_pandas_series_groupby_impl


@sdc_overload_method(SeriesType, 'isnull')
@sdc_overload_method(SeriesType, 'isna')
def hpat_pandas_series_isna(self):
    """
    Pandas Series method :meth:`pandas.Series.isna` and :meth:`pandas.Series.isnull` implementation.

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isna1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_str_isna1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_isnull1

    Parameters
    -----------
    self : :obj:`pandas.Series` object
               input argument

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method isna/isnull().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if isinstance(self.data.dtype, (types.Integer, types.Float)):

        def hpat_pandas_series_isna_impl(self):
            return pandas.Series(data=numpy.isnan(self._data), index=self._index, name=self._name)

        return hpat_pandas_series_isna_impl

    if isinstance(self.data.dtype, types.UnicodeType):

        def hpat_pandas_series_isna_impl(self):
            result = numpy.empty(len(self._data), numpy.bool_)
            byte_size = 8
            # iterate over bits in StringArrayType null_bitmap and fill array indicating if array's element are NaN
            for i in range(len(self._data)):
                bmap_idx = i // byte_size
                bit_idx = i % byte_size
                bmap = self._data.null_bitmap[bmap_idx]
                bit_value = (bmap >> bit_idx) & 1
                result[i] = bit_value == 0
            return pandas.Series(result, index=self._index, name=self._name)

        return hpat_pandas_series_isna_impl


@sdc_overload_method(SeriesType, 'notna')
def hpat_pandas_series_notna(self):
    """
    Pandas Series method :meth:`pandas.Series.notna` implementation.

    .. only:: developer

        Test: python -m -k sdc.runtests sdc.tests.test_series.TestSeries.test_series_notna*

    Parameters
    -----------
    self : :obj:`pandas.Series` object
        input series

    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method notna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_notna_impl(self):
            return pandas.Series(numpy.invert(numpy.isnan(self._data)), index=self._index, name=self._name)

        return hpat_pandas_series_notna_impl

    if isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_notna_impl(self):
            result = self.isna()
            return pandas.Series(numpy.invert(result._data), index=self._index, name=self._name)

        return hpat_pandas_series_notna_impl


@sdc_overload_method(SeriesType, 'ne')
def hpat_pandas_series_ne(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.ne` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method ne().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_ne_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data != other._data)

        return hpat_pandas_series_ne_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_ne_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data != other)

        return hpat_pandas_series_ne_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'add')
def hpat_pandas_series_add(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.add


    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_add.py
       :language: python
       :lines: 27-
       :caption: Getting the addition of Series and other
       :name: ex_series_add

    .. command-output:: python ./series/series_add.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.radd <pandas.Series.radd>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.add` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method add().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_add_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data + other._data)

        return hpat_pandas_series_add_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_add_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method add(). The object axis\n expected: 0')

            return pandas.Series(self._data + other)

        return hpat_pandas_series_add_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'sub')
def hpat_pandas_series_sub(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.sub` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method sub().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_sub_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data - other._data)

        return hpat_pandas_series_sub_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_sub_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data - other)

        return hpat_pandas_series_sub_number_impl

    raise TypingError('{} The object must be a pandas.series or scalar. Given other: {}'.format(_func_name, other))


@sdc_overload_method(SeriesType, 'sum')
def hpat_pandas_series_sum(
    self,
    axis=None,
    skipna=None,
    level=None,
    numeric_only=None,
    min_count=0,
):
    """
    Pandas Series method :meth:`pandas.Series.sum` implementation.

    .. only:: developer

        Tests:
            python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum1
            # python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum2

    Parameters
    ----------
    self: :class:`pandas.Series`
        input series
    axis:
        *unsupported*
    skipna: :obj:`bool`, default :obj:`True`
        Exclude NA/null values when computing the result.
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    min_count:
        *unsupported*

    Returns
    -------
    :obj:`float`
        scalar or Series (if level specified)
    """

    _func_name = 'Method sum().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.Omitted)) or axis is None):
        raise TypingError('{} The axis must be an Integer. Currently unsupported. Given: {}'.format(_func_name, axis))

    if not (isinstance(skipna, (types.Boolean, types.Omitted)) or skipna is None):
        raise TypingError('{} The skipna must be a Boolean. Given: {}'.format(_func_name, skipna))

    if not (isinstance(level, (types.Integer, types.StringLiteral, types.Omitted)) or level is None):
        raise TypingError(
            '{} The level must be an Integer or level name. Currently unsupported. Given: {}'.format(
                _func_name, level))

    if not (isinstance(numeric_only, (types.Boolean, types.Omitted)) or numeric_only is None):
        raise TypingError(
            '{} The numeric_only must be a Boolean. Currently unsupported. Given: {}'.format(
                _func_name, numeric_only))

    if not (isinstance(min_count, (types.Integer, types.Omitted)) or min_count == 0):
        raise TypingError(
            '{} The min_count must be an Integer. Currently unsupported. Given: {}'.format(
                _func_name, min_count))

    def hpat_pandas_series_sum_impl(
        self,
        axis=None,
        skipna=None,
        level=None,
        numeric_only=None,
        min_count=0,
    ):
        """
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_sum1
        """
        if skipna is None:
            skipna = True
        if skipna:
            return numpy.nansum(self._data)
        return numpy.sum(self._data)

    return hpat_pandas_series_sum_impl


@sdc_overload_method(SeriesType, 'take')
def hpat_pandas_series_take(self, indices, axis=0, is_copy=False):
    """
    Pandas Series method :meth:`pandas.Series.take` implementation.
    .. only:: developer
       Tests: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_default
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_default_unboxing
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_int
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_int_unboxing
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_str
              python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_take_index_str_unboxing
    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    indices: :obj:`array-like`
         An array of ints indicating which positions to take
    axis: {0 or `index`, 1 or `columns`, None}, default 0
        The axis on which to select elements. 0 means that we are selecting rows,
        1 means that we are selecting columns.
        *unsupported*
    is_copy: :obj:`bool`, default True
        Whether to return a copy of the original object or not.
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object containing the elements taken from the object
    """

    ty_checker = TypeChecker('Method take().')
    ty_checker.check(self, SeriesType)

    if (not isinstance(axis, (int, types.Integer, str, types.UnicodeType, types.StringLiteral, types.Omitted))
        and axis not in (0, 'index')):
        ty_checker.raise_exc(axis, 'integer or string', 'axis')

    if not isinstance(is_copy, (bool, types.Boolean, types.Omitted)) and is_copy is not False:
        ty_checker.raise_exc(is_copy, 'boolean', 'is_copy')

    if not isinstance(indices, (types.List, types.Array)):
        ty_checker.raise_exc(indices, 'array-like', 'indices')

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_take_noindex_impl(self, indices, axis=0, is_copy=False):
            local_data = [self._data[i] for i in indices]

            return pandas.Series(local_data, indices)

        return hpat_pandas_series_take_noindex_impl

    def hpat_pandas_series_take_impl(self, indices, axis=0, is_copy=False):
        local_data = [self._data[i] for i in indices]
        local_index = [self._index[i] for i in indices]

        return pandas.Series(local_data, local_index)

    return hpat_pandas_series_take_impl


@sdc_overload_method(SeriesType, 'idxmax')
def hpat_pandas_series_idxmax(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.idxmax` implementation.
    .. only:: developer
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_str_idx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_noidx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmax_idx

    Parameters
    -----------
    axis :  :obj:`int`, :obj:`str`, default: None
            Axis along which the operation acts
            0/None - row-wise operation
            1      - column-wise operation
            *unsupported*
    skipna:  :obj:`bool`, default: True
            exclude NA/null values
            *unsupported*
    Returns
    -------
    :obj:`pandas.Series.index` or nan
            returns: Label of the minimum value.
    """

    _func_name = 'Method idxmax().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Numeric values supported only. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean, bool)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None):
        raise TypingError("{} 'axis' unsupported. Given: {}".format(_func_name, axis))

    if not (isinstance(skipna, types.Omitted) or skipna is True):
        raise TypingError("{} 'skipna' unsupported. Given: {}".format(_func_name, skipna))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_idxmax_impl(self, axis=None, skipna=True):

            return numpy.argmax(self._data)

        return hpat_pandas_series_idxmax_impl
    else:
        def hpat_pandas_series_idxmax_index_impl(self, axis=None, skipna=True):
            # no numpy.nanargmax is supported by Numba at this time
            result = numpy.argmax(self._data)
            return self._index[int(result)]

        return hpat_pandas_series_idxmax_index_impl


@sdc_overload_method(SeriesType, 'mul')
def hpat_pandas_series_mul(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.mul

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_mul.py
       :language: python
       :lines: 27-
       :caption: Element-wise multiplication of two Series
       :name: ex_series_mul

    .. command-output:: python ./series/series_mul.py
       :cwd: ../../../examples

     .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rmul <pandas.Series.rmul>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.mul` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method mul().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(level, types.Omitted) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if not isinstance(fill_value, types.Omitted) and fill_value is not None:
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not isinstance(axis, types.Omitted) and axis != 0:
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_mul_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """
            if axis != 0:
                raise ValueError('Method mul(). The object axis\n expected: 0')

            return pandas.Series(self._data * other._data)

        return hpat_pandas_series_mul_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_mul_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method mul(). The object axis\n expected: 0')

            return pandas.Series(self._data * other)

        return hpat_pandas_series_mul_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'div')
def hpat_pandas_series_div(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.div

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_div.py
       :language: python
       :lines: 27-
       :caption: Element-wise division of one Series by another (binary operator div)
       :name: ex_series_div

    .. command-output:: python ./series/series_div.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rdiv <pandas.Series.rdiv>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.div` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: :obj:`int` default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method div().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(level, types.Omitted) or level is None):
        ty_checker.raise_exc(level, 'None', 'level')

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_div_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            if axis != 0:
                raise ValueError('Method div(). The object axis\n expected: 0')

            return pandas.Series(self._data / other._data)

        return hpat_pandas_series_div_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_div_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method div(). The object axis\n expected: 0')

            return pandas.Series(self._data / other)

        return hpat_pandas_series_div_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'truediv')
def hpat_pandas_series_truediv(self, other, level=None, fill_value=None, axis=0):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.truediv

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_truediv.py
       :language: python
       :lines: 27-
       :caption: Element-wise division of one Series by another (binary operator truediv)
       :name: ex_series_truediv

    .. command-output:: python ./series/series_truediv.py
       :cwd: ../../../examples

    .. note::

        Parameters level, fill_value, axis are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.rtruediv <pandas.Series.rtruediv>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series :meth:`pandas.Series.truediv` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method truediv().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not (isinstance(level, types.Omitted) or level is None):
        ty_checker.raise_exc(level, 'None', 'level')

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        ty_checker.raise_exc(fill_value, 'None', 'fill_value')

    if not (isinstance(axis, types.Omitted) or axis == 0):
        ty_checker.raise_exc(axis, 'int', 'axis')

    if isinstance(other, SeriesType):
        def hpat_pandas_series_truediv_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            if axis != 0:
                raise ValueError('Method truediv(). The object axis\n expected: 0')

            return pandas.Series(self._data / other._data)

        return hpat_pandas_series_truediv_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_truediv_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            if axis != 0:
                raise ValueError('Method truediv(). The object axis\n expected: 0')

            return pandas.Series(self._data / other)

        return hpat_pandas_series_truediv_number_impl

    ty_checker.raise_exc(other, 'Series, int, float', 'other')


@sdc_overload_method(SeriesType, 'floordiv')
def hpat_pandas_series_floordiv(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.floordiv` implementation.
    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5

    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method floordiv().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_floordiv_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data // other._data)

        return hpat_pandas_series_floordiv_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_floordiv_number_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data // other)

        return hpat_pandas_series_floordiv_number_impl

    raise TypingError('{} The object must be a pandas.series or scalar. Given other: {}'.format(_func_name, other))


@sdc_overload_method(SeriesType, 'pow')
def hpat_pandas_series_pow(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.pow` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method pow().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_pow_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data ** other._data)

        return hpat_pandas_series_pow_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_pow_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data ** other)

        return hpat_pandas_series_pow_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'prod')
def hpat_pandas_series_prod(self, axis=None, skipna=True, level=None, numeric_only=None, min_count=0):
    """
    Pandas Series method :meth:`pandas.Series.prod` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_prod

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    axis: {index (0)}
        Axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default :obj:`True`
        Exclude nan values when computing the result
    level: :obj:`int`, :obj:`str`, default :obj:`None`
        If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.
        *unsupported*
    numeric_only: :obj:`bool`, default :obj:`None`
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data.
        Not implemented for Series.
        *unsupported*
    min_count: :obj:`int`, default 0
        The required number of valid values to perform the operation.
        If fewer than min_count non-NA values are present the result will be NA.
        *unsupported*

    Returns
    -------
    :obj:
        Returns scalar or Series (if level specified)
    """

    _func_name = 'Method prod().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError('{} Non numeric values unsupported. Given: {}'.format(_func_name, self.data.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None) \
            or not (isinstance(min_count, types.Omitted) or min_count == 0):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}, min_count: {}'.format(
                _func_name, axis, level, numeric_only, min_count))

    def hpat_pandas_series_prod_impl(self, axis=None, skipna=True, level=None, numeric_only=None, min_count=0):
        if skipna:
            return numpy.nanprod(self._data)
        else:
            return numpy.prod(self._data)

    return hpat_pandas_series_prod_impl


@sdc_overload_method(SeriesType, 'quantile')
def hpat_pandas_series_quantile(self, q=0.5, interpolation='linear'):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.quantile

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_quantile.py
       :language: python
       :lines: 27-
       :caption: Computing quantile for the Series
       :name: ex_series_quantile

    .. command-output:: python ./series/series_quantile.py
       :cwd: ../../../examples

    .. note::

        Parameter interpolation is currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        `numpy.absolute <https://docs.scipy.org/doc/numpy/reference/generated/numpy.percentile.html#numpy.percentile>`_


    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.quantile` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_quantile
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_quantile_q_vector
    Parameters
    -----------
    q : :obj: float or array-like object, default 0.5
        the quantile(s) to compute
    interpolation: 'linear', 'lower', 'higher', 'midpoint', 'nearest', default `linear`
        *unsupported* by Numba
    Returns
    -------
    :obj:`pandas.Series` or float
    """

    _func_name = 'Method quantile().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(interpolation, types.Omitted) and interpolation is not 'linear':
        ty_checker.raise_exc(interpolation, 'str', 'interpolation')

    if not isinstance(q, (int, float, list, types.Number, types.Omitted, types.List)):
        ty_checker.raise_exc(q, 'int, float, list', 'q')

    def hpat_pandas_series_quantile_impl(self, q=0.5, interpolation='linear'):

        return numpy.quantile(self._data, q)

    return hpat_pandas_series_quantile_impl


@sdc_overload_method(SeriesType, 'rename')
def hpat_pandas_series_rename(self, index=None, copy=True, inplace=False, level=None):
    """
    Pandas Series method :meth:`pandas.Series.rename` implementation.
    Alter Series index labels or name.
    .. only:: developer
       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_rename

    Parameters
    -----------
    index : :obj:`scalar` or `hashable sequence` or `dict` or `function`
               Dict-like or functions are transformations to apply to the index.
               Scalar or hashable sequence-like will alter the Series.name attribute.
               Only scalar value is supported.
    copy : :obj:`bool`, default :obj:`True`
               Whether to copy underlying data.
    inplace : :obj:`bool`, default :obj:`False`
               Whether to return a new Series. If True then value of copy is ignored.
    level : :obj:`int` or `str`
               In case of a MultiIndex, only rename labels in the specified level.
               *Not supported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` with index labels or name altered.
    """

    ty_checker = TypeChecker('Method rename().')
    ty_checker.check(self, SeriesType)

    if not isinstance(index, (types.Omitted, types.UnicodeType,
                              types.StringLiteral, str,
                              types.Integer, types.Boolean,
                              types.Hashable, types.Float,
                              types.NPDatetime, types.NPTimedelta,
                              types.Number)) and index is not None:
        ty_checker.raise_exc(index, 'string', 'index')

    if not isinstance(copy, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(copy, 'boolean', 'copy')

    if not isinstance(inplace, (types.Omitted, types.Boolean, bool)):
        ty_checker.raise_exc(inplace, 'boolean', 'inplace')

    if not isinstance(level, (types.Omitted, types.UnicodeType,
                              types.StringLiteral, types.Integer)) and level is not None:
        ty_checker.raise_exc(level, 'Integer or srting', 'level')

    def hpat_pandas_series_rename_idx_impl(self, index=None, copy=True, inplace=False, level=None):
        if copy is True:
            series_data = self._data.copy()
            series_index = self._index.copy()
        else:
            series_data = self._data
            series_index = self._index

        return pandas.Series(data=series_data, index=series_index, name=index)

    def hpat_pandas_series_rename_noidx_impl(self, index=None, copy=True, inplace=False, level=None):
        if copy is True:
            series_data = self._data.copy()
        else:
            series_data = self._data

        return pandas.Series(data=series_data, index=self._index, name=index)

    if isinstance(self.index, types.NoneType):
        return hpat_pandas_series_rename_noidx_impl
    return hpat_pandas_series_rename_idx_impl


@sdc_overload_method(SeriesType, 'min')
def hpat_pandas_series_min(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.min` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_min
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_min_param
    Parameters
    -----------
    axis:
        *unsupported*
    skipna: :obj:`bool` object
        Exclude nan values when computing the result
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    Returns
    -------
    :obj:
         returns :obj: scalar
    """

    _func_name = 'Method min().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not True:
        raise TypingError(
            '{} The parameter must be a boolean type. Given type skipna: {}'.format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}'.format(_func_name, axis, level,
                                                                                            numeric_only))

    def hpat_pandas_series_min_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmin(self._data)

        return self._data.min()

    return hpat_pandas_series_min_impl


@sdc_overload_method(SeriesType, 'max')
def hpat_pandas_series_max(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.max

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_max.py
       :language: python
       :lines: 27-
       :caption: Getting the maximum value of Series elements
       :name: ex_series_max

    .. command-output:: python ./series/series_max.py
       :cwd: ../../../examples

    .. note::

        Parameters axis, level, numeric_only are currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.sum <pandas.Series.sum>`
            Return the sum.
        :ref:`Series.min <pandas.Series.min>`
            Return the minimum.
        :ref:`Series.max <pandas.Series.max>`
            Return the maximum.
        :ref:`Series.idxmin <pandas.Series.idxmin>`
            Return the index of the minimum.
        :ref:`Series.idxmax <pandas.Series.idxmax>`
            Return the index of the maximum.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.max` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_max
             python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_max_param
    Parameters
    -----------
    axis:
        *unsupported*
    skipna: :obj:`bool` object
        Exclude nan values when computing the result
    level:
        *unsupported*
    numeric_only:
        *unsupported*
    Returns
    -------
    :obj:
         returns :obj: scalar
    """

    _func_name = 'Method max().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(self.data.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not True:
        ty_checker.raise_exc(skipna, 'bool', 'skipna')

    if not isinstance(axis, types.Omitted) and axis is not None:
        ty_checker.raise_exc(axis, 'None', 'axis')

    if not isinstance(level, types.Omitted) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if not isinstance(numeric_only, types.Omitted) and numeric_only is not None:
        ty_checker.raise_exc(numeric_only, 'None', 'numeric_only')

    def hpat_pandas_series_max_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmax(self._data)

        return self._data.max()

    return hpat_pandas_series_max_impl


@sdc_overload_method(SeriesType, 'mean')
def hpat_pandas_series_mean(self, axis=None, skipna=None, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.mean` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_mean

    Parameters
    -----------
    axis: {index (0)}
        Axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default True
        Exclude NA/null values when computing the result.
    level: :obj:`int` or level name, default None
        If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.
        *unsupported*
    numeric_only: :obj:`bool`, default None
        Include only float, int, boolean columns.
        If None, will attempt to use everything, then use only numeric data. Not implemented for Series.
        *unsupported*

    Returns
    -------
    :obj:
         Return the mean of the values for the requested axis.
    """

    _func_name = 'Method mean().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError(
            '{} Currently function supports only numeric values. Given data type: {}'.format(
                _func_name, self.data.dtype))

    if not isinstance(skipna, (types.Omitted, types.Boolean)) and skipna is not None:
        raise TypingError(
            '{} The parameter must be a boolean type. Given type skipna: {}'.format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None) \
            or not (isinstance(level, types.Omitted) or level is None) \
            or not (isinstance(numeric_only, types.Omitted) or numeric_only is None):
        raise TypingError(
            '{} Unsupported parameters. Given axis: {}, level: {}, numeric_only: {}'.format(_func_name, axis, level,
                                                                                            numeric_only))

    def hpat_pandas_series_mean_impl(self, axis=None, skipna=None, level=None, numeric_only=None):
        if skipna is None:
            skipna = True

        if skipna:
            return numpy.nanmean(self._data)

        return self._data.mean()

    return hpat_pandas_series_mean_impl


@sdc_overload_method(SeriesType, 'mod')
def hpat_pandas_series_mod(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.mod` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method mod().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_mod_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5
            """

            return pandas.Series(self._data % other._data)

        return hpat_pandas_series_mod_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_mod_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op5_float_scalar
            """

            return pandas.Series(self._data % other)

        return hpat_pandas_series_mod_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'eq')
def hpat_pandas_series_eq(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.eq` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method eq().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_eq_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data == other._data)

        return hpat_pandas_series_eq_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_eq_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data == other)

        return hpat_pandas_series_eq_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'ge')
def hpat_pandas_series_ge(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.ge` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method ge().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_ge_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data >= other._data)

        return hpat_pandas_series_ge_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_ge_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data >= other)

        return hpat_pandas_series_ge_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'idxmin')
def hpat_pandas_series_idxmin(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.idxmin` implementation.

    .. only:: developer

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin1
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_str
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_str_idx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_no
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_int
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_noidx
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_idxmin_idx

    Parameters
    -----------
    axis :  :obj:`int`, :obj:`str`, default: None
            Axis along which the operation acts
            0/None - row-wise operation
            1      - column-wise operation
            *unsupported*
    skipna:  :obj:`bool`, default: True
            exclude NA/null values
            *unsupported*

    Returns
    -------
    :obj:`pandas.Series.index` or nan
            returns: Label of the minimum value.
    """

    _func_name = 'Method idxmin().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Numeric values supported only. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(skipna, (types.Omitted, types.Boolean, bool)) or skipna is True):
        raise TypingError("{} 'skipna' must be a boolean type. Given: {}".format(_func_name, skipna))

    if not (isinstance(axis, types.Omitted) or axis is None):
        raise TypingError("{} 'axis' unsupported. Given: {}".format(_func_name, axis))

    if not (isinstance(skipna, types.Omitted) or skipna is True):
        raise TypingError("{} 'skipna' unsupported. Given: {}".format(_func_name, skipna))

    if isinstance(self.index, types.NoneType) or self.index is None:
        def hpat_pandas_series_idxmin_impl(self, axis=None, skipna=True):

            return numpy.argmin(self._data)

        return hpat_pandas_series_idxmin_impl
    else:
        def hpat_pandas_series_idxmin_index_impl(self, axis=None, skipna=True):
            # no numpy.nanargmin is supported by Numba at this time
            result = numpy.argmin(self._data)
            return self._index[int(result)]

        return hpat_pandas_series_idxmin_index_impl


@sdc_overload_method(SeriesType, 'lt')
def hpat_pandas_series_lt(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.lt` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method lt().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_lt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data < other._data)

        return hpat_pandas_series_lt_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_lt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data < other)

        return hpat_pandas_series_lt_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'gt')
def hpat_pandas_series_gt(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.gt` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method gt().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_gt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data > other._data)

        return hpat_pandas_series_gt_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_gt_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data > other)

        return hpat_pandas_series_gt_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'le')
def hpat_pandas_series_le(self, other, level=None, fill_value=None, axis=0):
    """
    Pandas Series method :meth:`pandas.Series.le` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
    Parameters
    ----------
    self: :class:`pandas.Series`
        input arg
    other: :obj:`pandas.Series`, :obj:`int` or :obj:`float`
        input arg
    level: :obj:`int` or name
         *unsupported*
    fill_value: :obj:`float` or None, default None
              *unsupported*
    axis: default 0
         *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method le().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(level, types.Omitted) or level is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(fill_value, types.Omitted) or fill_value is None):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if not (isinstance(axis, types.Omitted) or axis == 0):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, fill_value: {}, axis: {}'.format(_func_name, level, fill_value,
                                                                                          axis))

    if isinstance(other, SeriesType):
        def hpat_pandas_series_le_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8
            """

            return pandas.Series(self._data <= other._data)

        return hpat_pandas_series_le_impl

    if isinstance(other, types.Integer) or isinstance(other, types.Float):
        def hpat_pandas_series_le_impl(self, other, level=None, fill_value=None, axis=0):
            """
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_integer_scalar
            Test:  python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_op8_float_scalar
            """

            return pandas.Series(self._data <= other)

        return hpat_pandas_series_le_impl

    raise TypingError(
        '{} The object must be a pandas.series and argument must be a number. Given: {} and other: {}'.format(
            _func_name, self, other))


@sdc_overload_method(SeriesType, 'abs')
def hpat_pandas_series_abs(self):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.abs


    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_abs.py
       :language: python
       :lines: 27-
       :caption: Getting the absolute value of each element in Series
       :name: ex_series_abs

    .. command-output:: python ./series/series_abs.py
       :cwd: ../../../examples

    .. seealso::

        `numpy.absolute <https://docs.scipy.org/doc/numpy/reference/generated/numpy.absolute.html>`_
            Calculate the absolute value element-wise.

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************

    Pandas Series method :meth:`pandas.Series.abs` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_abs1
    Parameters
    -----------
    self: :obj:`pandas.Series`
          input series
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` containing the absolute value of elements
    """

    _func_name = 'Method abs().'

    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(self.dtype, (types.Integer, types.Float)):
        raise TypingError(
            '{} The function only applies to elements that are all numeric. Given data type: {}'.format(_func_name,
                                                                                                        self.dtype))

    def hpat_pandas_series_abs_impl(self):
        return pandas.Series(numpy.abs(self._data))

    return hpat_pandas_series_abs_impl


@sdc_overload_method(SeriesType, 'unique')
def hpat_pandas_series_unique(self):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.unique

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_unique.py
       :language: python
       :lines: 27-
       :caption: Getting unique values in Series
       :name: ex_series_unique

    .. command-output:: python ./series/series_unique.py
       :cwd: ../../../examples

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.unique` implementation.
    Note: Return values order is unspecified
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique_sorted
    Parameters
    -----------
    self: :class:`pandas.Series`
        input arg
    Returns
    -------
    :obj:`numpy.array`
         returns :obj:`numpy.array` ndarray
    """

    ty_checker = TypeChecker('Method unique().')
    ty_checker.check(self, SeriesType)

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_unique_str_impl(self):
            '''
            Returns sorted unique elements of an array
            Note: Can't use Numpy due to StringArrayType has no ravel() for noPython mode.
            Also, NotImplementedError: unicode_type cannot be represented as a Numpy dtype

            Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique_str
            '''

            str_set = set(self._data)
            return to_array(str_set)

        return hpat_pandas_series_unique_str_impl

    def hpat_pandas_series_unique_impl(self):
        '''
        Returns sorted unique elements of an array

        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_unique
        '''

        return numpy.unique(self._data)

    return hpat_pandas_series_unique_impl


@sdc_overload_method(SeriesType, 'cumsum')
def hpat_pandas_series_cumsum(self, axis=None, skipna=True):
    """
    Pandas Series method :meth:`pandas.Series.cumsum` implementation.

    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_unboxing
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_full
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_str
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_cumsum_unsupported_axis

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int`, :obj:`str`
        Axis along which the operation acts
        0/None/'index' - row-wise operation
        1/'columns'    - column-wise operation
        *unsupported*
    skipna: :obj:`bool`
        exclude NA/null values
    *args:
        *unsupported*

    Returns
    -------
    :obj:`scalar`, :obj:`pandas.Series`
         returns :obj:`scalar` or :obj:`pandas.Series` object
    """

    _func_name = 'Method cumsum().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        msg = '{} The object must be a number. Given self.data.dtype: {}'
        raise TypingError(msg.format(_func_name, self.data.dtype))

    if not isinstance(axis, (types.Omitted, types.NoneType)) and axis is not None:
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    def hpat_pandas_series_cumsum_impl(self, axis=None, skipna=True):
        if skipna:
            # nampy.nancumsum replaces NANs with 0, series.cumsum does not, so replace back 0 with NANs
            local_data = numpy.nancumsum(self._data)
            local_data[numpy.isnan(self._data)] = numpy.nan
            return pandas.Series(local_data)

        return pandas.Series(self._data.cumsum())

    return hpat_pandas_series_cumsum_impl


@sdc_overload_method(SeriesType, 'nunique')
def hpat_pandas_series_nunique(self, dropna=True):
    """
    Pandas Series method :meth:`pandas.Series.nunique` implementation.

    Note: Unsupported mixed numeric and string data
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_nunique
    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    dropna: :obj:`bool`, default True
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method nunique().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if isinstance(self.data, StringArrayType):

        def hpat_pandas_series_nunique_str_impl(self, dropna=True):
            """
            It is better to merge with Numeric branch
            """

            data = self._data
            if dropna:
                nan_mask = self.isna()
                data = self._data[~nan_mask._data]
            unique_values = set(data)
            return len(unique_values)

        return hpat_pandas_series_nunique_str_impl

    def hpat_pandas_series_nunique_impl(self, dropna=True):
        """
        This function for Numeric data because NumPy dosn't support StringArrayType
        Algo looks a bit ambigous because, currently, set() can not be used with NumPy with Numba JIT
        """

        data_mask_for_nan = numpy.isnan(self._data)
        nan_exists = numpy.any(data_mask_for_nan)
        data_no_nan = self._data[~data_mask_for_nan]
        data_set = set(data_no_nan)
        if dropna or not nan_exists:
            return len(data_set)
        else:
            return len(data_set) + 1

    return hpat_pandas_series_nunique_impl


@sdc_overload_method(SeriesType, 'count')
def hpat_pandas_series_count(self, level=None):
    """
    Intel Scalable Dataframe Compiler User Guide
    ********************************************

    Pandas API: pandas.Series.count

    Examples
    --------
    .. literalinclude:: ../../../examples/series/series_count.py
       :language: python
       :lines: 27-
       :caption: Counting non-NaN values in Series
       :name: ex_series_count

    .. command-output:: python ./series/series_count.py
       :cwd: ../../../examples

    .. note::

        Parameter level is currently unsupported by Intel Scalable Dataframe Compiler

    .. seealso::

        :ref:`Series.value_counts <pandas.Series.value_counts>`
        :ref:`Series.value_counts <pandas.Series.value_counts>`
        :ref:`Series.str.len <pandas.Series.str.len>`

    Intel Scalable Dataframe Compiler Developer Guide
    *************************************************
    Pandas Series method :meth:`pandas.Series.count` implementation.
    .. only:: developer
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_count
    Parameters

    -----------
    self: :obj:`pandas.Series`
          input series
    level:  :obj:`int` or name
           *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    _func_name = 'Method count().'
    ty_checker = TypeChecker(_func_name)
    ty_checker.check(self, SeriesType)

    if not isinstance(level, (types.Omitted, types.NoneType)) and level is not None:
        ty_checker.raise_exc(level, 'None', 'level')

    if isinstance(self.data, StringArrayType):
        def hpat_pandas_series_count_str_impl(self, level=None):

            nan_mask = self.isna()
            return numpy.sum(nan_mask._data == 0)

        return hpat_pandas_series_count_str_impl

    def hpat_pandas_series_count_impl(self, level=None):
        """
        Return number of non-NA/null observations in the object
        Returns number of unique elements in the object
        Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_count
        """
        data_no_nan = self._data[~numpy.isnan(self._data)]
        return len(data_no_nan)

    return hpat_pandas_series_count_impl


@sdc_overload_method(SeriesType, 'median')
def hpat_pandas_series_median(self, axis=None, skipna=True, level=None, numeric_only=None):
    """
    Pandas Series method :meth:`pandas.Series.median` implementation.

    .. only:: developer

       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median_skipna_default1
       Test: python -m sdc.runtests sdc.tests.test_series.TestSeries.test_series_median_skipna_false1

    Parameters
    -----------
    self: :obj:`pandas.Series`
          input series
    axis: :obj:`int` or :obj:`string` {0 or `index`, None}, default None
        The axis for the function to be applied on.
        *unsupported*
    skipna: :obj:`bool`, default True
        exclude NA/null values when computing the result
    level: :obj:`int` or :obj:`string`, default None
         *unsupported*
    numeric_only: :obj:`bool` or None, default None
         *unsupported*

    Returns
    -------
    :obj:`float` or :obj:`pandas.Series` (if level is specified)
         median of values in the series

    """

    _func_name = 'Method median().'

    if not isinstance(self, SeriesType):
        raise TypingError(
            '{} The object must be a pandas.series. Given self: {}'.format(_func_name, self))

    if not isinstance(self.dtype, types.Number):
        raise TypingError(
            '{} The function only applies to elements that are all numeric. Given data type: {}'.format(
                _func_name, self.dtype))

    if not (isinstance(axis, (types.Integer, types.UnicodeType, types.Omitted)) or axis is None):
        raise TypingError(
            '{} The axis must be an Integer or a String. Currently unsupported. Given: {}'.format(
                _func_name, axis))

    if not (isinstance(skipna, (types.Boolean, types.Omitted)) or skipna):
        raise TypingError('{} The is_copy must be a boolean. Given: {}'.format(_func_name, skipna))

    if not ((level is None or isinstance(level, types.Omitted))
            and (numeric_only is None or isinstance(numeric_only, types.Omitted))
            and (axis is None or isinstance(axis, types.Omitted))
            ):
        raise TypingError(
            '{} Unsupported parameters. Given level: {}, numeric_only: {}, axis: {}'.format(
                _func_name, level, numeric_only, axis))

    def hpat_pandas_series_median_impl(self, axis=None, skipna=True, level=None, numeric_only=None):
        if skipna:
            return numpy.nanmedian(self._data)

        return numpy.median(self._data)

    return hpat_pandas_series_median_impl


@sdc_overload_method(SeriesType, 'argsort')
def hpat_pandas_series_argsort(self, axis=0, kind='quicksort', order=None):
    """
    Pandas Series method :meth:`pandas.Series.argsort` implementation.

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_argsort*

    Parameters
    -----------
    self: :class:`pandas.Series`
        input series
    axis: :obj:`int`
        Has no effect but is accepted for compatibility with numpy.
        *unsupported*
    kind: :obj:'str', {'mergesort', 'quicksort', 'heapsort'}, default: 'quicksort'
        Choice of sorting algorithm. See np.sort for more information. 'mergesort' is the only stable algorithm
        *uses python func - sorted() for str and numpy func - sort() for num*
        *'heapsort' unsupported*
    order: :obj:`str` or  :obj:`list of str`, default: None
        Has no effect but is accepted for compatibility with numpy.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
         returns: Positions of values within the sort order with -1 indicating nan values.
    """

    _func_name = 'Method argsort().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not isinstance(self.data.dtype, types.Number):
        raise TypingError('{} Non-numeric type unsupported. Given: {}'.format(_func_name, self.data.dtype))

    if not (isinstance(axis, types.Omitted) or isinstance(axis, types.Integer) or axis == 0):
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    if not isinstance(kind, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Non-string type unsupported. Given kind: {}'.format(_func_name, kind))

    if not isinstance(order, (str, types.UnicodeType, types.StringLiteral, types.Omitted, types.NoneType, types.List))\
            and order is not None:
        raise TypingError('{} Unsupported parameters. Given order: {}'.format(_func_name, order))

    if not isinstance(self.index, types.NoneType):
        def hpat_pandas_series_argsort_idx_impl(self, axis=0, kind='quicksort', order=None):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method argsort(). Unsupported parameter. Given 'kind' != 'quicksort' or 'mergesort'")
            if kind == 'mergesort':
                #It is impossible to use numpy.argsort(self._data, kind=kind) since numba gives typing error
                sort = numpy.argsort(self._data, kind='mergesort')
            else:
                sort = numpy.argsort(self._data)
            na = self.isna().sum()
            result = numpy.empty(len(self._data), dtype=numpy.int64)
            na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
            if kind == 'mergesort':
                sort_nona = numpy.argsort(self._data[~na_data_arr], kind='mergesort')
            else:
                sort_nona = numpy.argsort(self._data[~na_data_arr])
            q = 0
            for id, i in enumerate(sort):
                if id in set(sort[len(self._data) - na:]):
                    q += 1
                else:
                    result[id] = sort_nona[id - q]
            for i in sort[len(self._data) - na:]:
                result[i] = -1

            return pandas.Series(result, self._index)

        return hpat_pandas_series_argsort_idx_impl

    def hpat_pandas_series_argsort_noidx_impl(self, axis=0, kind='quicksort', order=None):
        if kind != 'quicksort' and kind != 'mergesort':
            raise ValueError("Method argsort(). Unsupported parameter. Given 'kind' != 'quicksort' or 'mergesort'")
        if kind == 'mergesort':
            sort = numpy.argsort(self._data, kind='mergesort')
        else:
            sort = numpy.argsort(self._data)
        na = self.isna().sum()
        result = numpy.empty(len(self._data), dtype=numpy.int64)
        na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
        if kind == 'mergesort':
            sort_nona = numpy.argsort(self._data[~na_data_arr], kind='mergesort')
        else:
            sort_nona = numpy.argsort(self._data[~na_data_arr])
        q = 0
        for id, i in enumerate(sort):
            if id in set(sort[len(self._data) - na:]):
                q += 1
            else:
                result[id] = sort_nona[id - q]
        for i in sort[len(self._data) - na:]:
            result[i] = -1

        return pandas.Series(result)

    return hpat_pandas_series_argsort_noidx_impl


@sdc_overload_method(SeriesType, 'sort_values')
def hpat_pandas_series_sort_values(self, axis=0, ascending=True, inplace=False, kind='quicksort', na_position='last'):
    """
    Pandas Series method :meth:`pandas.Series.sort_values` implementation.

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_sort_values*

    Parameters
    -----------
    self: :class:'pandas.Series'
        input series
    axis: 0 or :obj:'pandas.Series.index', default: 0
        Axis to direct sorting.
        *unsupported*
    ascending: :obj:'bool', default: True
        If True, sort values in ascending order, otherwise descending.
    kind: :obj:'str', {'mergesort', 'quicksort', 'heapsort'}, default: 'quicksort'
        Choice of sorting algorithm.
        *uses python func - sorted() for str and numpy func - sort() for num*
        *'heapsort' unsupported*
    na_position: {'first' or 'last'}, default 'last'
        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.
        *unsupported*

    Returns
    -------
    :obj:`pandas.Series`
    """

    _func_name = 'Method sort_values().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, types.Omitted) or isinstance(axis, types.Integer) or axis == 0):
        raise TypingError('{} Unsupported parameters. Given axis: {}'.format(_func_name, axis))

    if not (isinstance(ascending, types.Omitted) or isinstance(ascending, types.Boolean) or ascending is True or False):
        raise TypingError('{} Unsupported parameters. Given ascending: {}'.format(_func_name, ascending))

    if not isinstance(kind, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Non-string type unsupported. Given kind: {}'.format(_func_name, kind))

    if not isinstance(na_position, (types.Omitted, str, types.UnicodeType, types.StringLiteral)):
        raise TypingError('{} Unsupported parameters. Given na_position: {}'.format(_func_name, na_position))

    if isinstance(self.index, types.NoneType) and isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_sort_values_str_noidx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            index = numpy.arange(len(self._data))
            my_index = numpy.arange(len(self._data))
            used_index = numpy.full((len(self._data)), -1)
            result = sorted(self._data)
            cycle = range(len(self._data))
            if not ascending:
                result = result[::-1]
                cycle = range(len(self._data) - 1, -1, -1)
            result_index = index.copy()
            for i in range(len(result_index)):
                find = 0
                for search in cycle:
                    check = 0
                    for j in used_index:
                        if my_index[search] == j:
                            check = 1
                    if (self._data[search] == result[i]) and check == 0 and find == 0:
                        result_index[i] = index[search]
                        used_index[i] = my_index[search]
                        find = 1
            na = self.isna().sum()
            num = 0
            for i in self.isna():
                j = len(result_index) - na
                if i and used_index[j] == -1:
                    result_index[j] = index[num]
                    used_index[j] = my_index[num]
                    na -= 1
                num += 1

            return pandas.Series(result, result_index)

        return hpat_pandas_series_sort_values_str_noidx_impl

    if isinstance(self.index, types.NoneType) and isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_sort_values_num_noidx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            na = self.isna().sum()
            indices = numpy.arange(len(self._data))
            if kind == 'mergesort':
                # It is impossible to use numpy.argsort(self._data, kind=kind) since numba gives typing error
                index_result = numpy.argsort(self._data, kind='mergesort')
            else:
                index_result = numpy.argsort(self._data)
            result = numpy.sort(self._data)
            i = len(self._data) - na
            index_result[i:] = index_result[i:][::-1]
            if not ascending:
                index_result[:i] = index_result[:i][::-1]
                result[:i] = result[:i][::-1]
            for i in range(len(index_result)):
                indices[i] = index_result[i]

            return pandas.Series(result, indices)

        return hpat_pandas_series_sort_values_num_noidx_impl

    if isinstance(self.data.dtype, types.UnicodeType):
        def hpat_pandas_series_sort_values_str_idx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            index = self._index
            my_index = numpy.arange(len(self._data))
            used_index = numpy.full((len(self._data)), -1)
            result = sorted(self._data)
            cycle = range(len(self._data))
            if not ascending:
                result = result[::-1]
                cycle = range(len(self._data) - 1, -1, -1)
            result_index = self._index.copy()
            for i in range(len(result_index)):
                find = 0
                for search in cycle:
                    check = 0
                    for j in used_index:
                        if my_index[search] == j:
                            check = 1
                    if (self._data[search] == result[i]) and check == 0 and find == 0:
                        result_index[i] = index[search]
                        used_index[i] = my_index[search]
                        find = 1
            na = self.isna().sum()
            num = 0
            for i in self.isna():
                j = len(result_index) - na
                if i and used_index[j] == -1:
                    result_index[j] = index[num]
                    used_index[j] = my_index[num]
                    na -= 1
                num += 1

            return pandas.Series(result, result_index)

        return hpat_pandas_series_sort_values_str_idx_impl

    if isinstance(self.data.dtype, types.Number):
        def hpat_pandas_series_sort_values_num_idx_impl(self, axis=0, ascending=True, inplace=False, kind='quicksort',
                                                na_position='last'):
            if kind != 'quicksort' and kind != 'mergesort':
                raise ValueError("Method sort_values(). Unsupported parameter. Given kind != 'quicksort', 'mergesort'")
            na = self.isna().sum()
            indices = self._index.copy()
            if kind == 'mergesort':
                index_result = numpy.argsort(self._data, kind='mergesort')
            else:
                index_result = numpy.argsort(self._data)
            result = numpy.sort(self._data)
            i = len(self._data) - na
            index_result[i:] = index_result[i:][::-1]
            if not ascending:
                index_result[:i] = index_result[:i][::-1]
                result[:i] = result[:i][::-1]
            for i in range(len(index_result)):
                indices[i] = self._index[index_result[i]]

            return pandas.Series(result, indices)

        return hpat_pandas_series_sort_values_num_idx_impl


@sdc_overload_method(SeriesType, 'dropna')
def hpat_pandas_series_dropna(self, axis=0, inplace=False):
    """
    Pandas Series method :meth:`pandas.Series.dropna` implementation.

    .. only:: developer
       Tests: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_dropna*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    axis: :obj:`int` or :obj:`string` {0 or `index`}, default 0
        There is only one axis to drop values from.
    inplace: :obj:`bool`, default False
        If True, do operation inplace and return None.
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object with NA entries dropped from it.
    """

    _func_name = 'Method dropna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.StringLiteral, types.UnicodeType, types.Omitted)) or axis == 0):
        raise TypingError('{} The axis must be an Integer or String. Given: {}'.format(_func_name, axis))

    if not (inplace is False or isinstance(inplace, types.Omitted)):
        raise TypingError('{} Unsupported parameters. Given inplace: {}'.format(_func_name, inplace))

    def hpat_pandas_series_dropna_impl(self, axis=0, inplace=False):
        # generate Series index if needed by using SeriesType.index (i.e. not self._index)
        na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
        data = self._data[~na_data_arr]
        index = self.index[~na_data_arr]
        return pandas.Series(data, index, self._name)

    return hpat_pandas_series_dropna_impl


@sdc_overload_method(SeriesType, 'fillna')
def hpat_pandas_series_fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
    """
    Pandas Series method :meth:`pandas.Series.fillna` implementation.

    .. only:: developer

       Tests: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_fillna*

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    value: scalar of the same dtype as input Series (other types currently unsupported), default None
        Value to use to fill the NA elements
    method: :obj:`string` {`backfill`, `bfill`, `pad`, `ffill`, None}, default None
        Method to use for filling holes in reindexed Series.
        *unsupported*
    axis: :obj:`int` or :obj:`string` {0 or `index`}, default None
        There is only one axis to drop values from.
    inplace: :obj:`bool`, default False
        If True, do operation inplace and return None.
        Supported as literal value only
    limit: :obj:`int`, default None
        If method is specified, this is the maximum number of consecutive NaN
        values to forward/backward fill.
        *unsupported*
    downcast: :obj:`dict` or :obj:`string` {`infer`}, default None
        Controls logic of downcasting elements to particular dtype
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` with missed values filled.
    """

    _func_name = 'Method fillna().'

    if not isinstance(self, SeriesType):
        raise TypingError('{} The object must be a pandas.series. Given: {}'.format(_func_name, self))

    if not (isinstance(axis, (types.Integer, types.StringLiteral, types.UnicodeType, types.Omitted)) or axis is None):
        raise TypingError('{} The axis must be an Integer or String. Given: {}'.format(_func_name, axis))

    if not (isinstance(inplace, types.Literal) and isinstance(inplace, types.Boolean)
            or isinstance(inplace, types.Omitted)
            or inplace is False):
        raise TypingError('{} The inplace must be a literal Boolean constant. Given: {}'.format(_func_name, inplace))

    if not ((method is None or isinstance(method, types.Omitted))
            and (limit is None or isinstance(limit, types.Omitted))
            and (downcast is None or isinstance(downcast, types.Omitted))
    ):
        raise TypingError('{} Unsupported parameters. Given method: {}, limit: {}, downcast: {}'.format(
                _func_name, method, limit, downcast))

    # inplace value has to be known at compile time to select between implementations with different signatures
    if ((isinstance(inplace, types.Literal) and inplace.literal_value == True)
        or (isinstance(inplace, bool) and inplace == True)):
        # do operation inplace, fill the NA/NaNs in the same array and return None
        if isinstance(self.dtype, types.UnicodeType):
            # TODO: StringArrayType cannot resize inplace, and assigning a copy back to self._data is not possible now
            raise TypingError('{} Not implemented when Series dtype is {} and inplace={}'.format(_func_name, self.dtype, inplace))

        elif isinstance(self.dtype, (types.Integer, types.Boolean)):
            def hpat_pandas_series_no_nan_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                # no NaNs in series of Integers or Booleans
                return None

            return hpat_pandas_series_no_nan_fillna_impl
        else:
            def hpat_pandas_series_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
                self._data[na_data_arr] = value
                return None

            return hpat_pandas_series_fillna_impl
    else:
        # non inplace implementations, copy array, fill the NA/NaN and return a new Series
        if isinstance(self.dtype, types.UnicodeType):
            # For StringArrayType implementation is taken from _series_fillna_str_alloc_impl
            # (can be called directly when it's index handling is fixed)
            def hpat_pandas_series_str_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):

                n = len(self._data)
                num_chars = 0
                # get total chars in new array
                for i in numba.parfor.internal_prange(n):
                    s = self._data[i]
                    if sdc.hiframes.api.isna(self._data, i):
                        num_chars += len(value)
                    else:
                        num_chars += len(s)

                filled_data = sdc.str_arr_ext.pre_alloc_string_array(n, num_chars)
                for i in numba.parfor.internal_prange(n):
                    if sdc.hiframes.api.isna(self._data, i):
                        filled_data[i] = value
                    else:
                        filled_data[i] = self._data[i]
                return pandas.Series(filled_data, self._index, self._name)

            return hpat_pandas_series_str_fillna_impl

        elif isinstance(self.dtype, (types.Integer, types.Boolean)):
            def hpat_pandas_series_no_nan_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                return pandas.Series(numpy.copy(self._data), self._index, self._name)

            return hpat_pandas_series_no_nan_fillna_impl

        else:
            def hpat_pandas_series_fillna_impl(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None):
                na_data_arr = sdc.hiframes.api.get_nan_mask(self._data)
                filled_data = numpy.copy(self._data)
                filled_data[na_data_arr] = value
                return pandas.Series(filled_data, self._index, self._name)

            return hpat_pandas_series_fillna_impl


@sdc_overload_method(SeriesType, 'cov')
def hpat_pandas_series_cov(self, other, min_periods=None):
    """
    Pandas Series method :meth:`pandas.Series.cov` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_cov

    Parameters
    ----------
    self: :obj:`pandas.Series`
        input series
    other: :obj:`pandas.Series`
        input series
    min_periods: :obj:`int`, default None

    Returns
    -------
    :obj:`float`
         returns :obj:`float` object
    """

    ty_checker = TypeChecker('Method cov().')
    ty_checker.check(self, SeriesType)

    ty_checker.check(other, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data.dtype, 'number', 'self.data')

    if not isinstance(other.data.dtype, types.Number):
        ty_checker.raise_exc(other.data.dtype, 'number', 'other.data')

    if not isinstance(min_periods, (types.Integer, types.Omitted, types.NoneType)) and min_periods is not None:
        ty_checker.raise_exc(min_periods, 'int64', 'min_periods')

    def hpat_pandas_series_cov_impl(self, other, min_periods=None):

        if min_periods is None:
            min_periods = 1

        if len(self._data) == 0 or len(other._data) == 0:
            return numpy.nan

        self_arr = self._data[:min(len(self._data), len(other._data))]
        other_arr = other._data[:min(len(self._data), len(other._data))]

        invalid = numpy.isnan(self_arr) | numpy.isnan(other_arr)
        if invalid.any():
            self_arr = self_arr[~invalid]
            other_arr = other_arr[~invalid]

        if len(self_arr) < min_periods:
            return numpy.nan

        new_self = pandas.Series(self_arr)

        ma = new_self.mean()
        mb = other.mean()

        if numpy.isinf(mb):
            return numpy.nan

        return ((self_arr - ma) * (other_arr - mb)).sum() / (new_self.count() - 1.0)

    return hpat_pandas_series_cov_impl


@sdc_overload_method(SeriesType, 'pct_change')
def hpat_pandas_series_pct_change(self, periods=1, fill_method='pad', limit=None, freq=None):
    """
    Pandas Series method :meth:`pandas.Series.pct_change` implementation.

    Note: Unsupported mixed numeric and string data

    .. only:: developer

       Test: python -m sdc.runtests -k sdc.tests.test_series.TestSeries.test_series_pct_change

    Parameters
    -----------
    self: :obj:`pandas.Series`
        input series
    periods: :obj:`int`, default 1
        Periods to shift for forming percent change.
    fill_method: :obj:`str`, default 'pad'
        How to handle NAs before computing percent changes.
    limit: :obj:`int`, default Nogne
        The number of consecutive NAs to fill before stopping.
        *unsupported*
    freq: :obj: DateOffset, timedelta, or offset alias string, optional
        Increment to use from time series API (e.g. 'M' or BDay()).
        *unsupported*
    Returns
    -------
    :obj:`pandas.Series`
         returns :obj:`pandas.Series` object
    """

    ty_checker = TypeChecker('Method pct_change().')
    ty_checker.check(self, SeriesType)

    if not isinstance(self.data.dtype, types.Number):
        ty_checker.raise_exc(self.data.dtype, 'number', 'self.data')

    if not isinstance(periods, (types.Integer, types.Omitted)):
        ty_checker.raise_exc(periods, 'int64', 'periods')

    if not isinstance(fill_method, (str, types.UnicodeType, types.StringLiteral, types.NoneType, types.Omitted)):
        ty_checker.raise_exc(fill_method, 'string', 'fill_method')

    if not isinstance(limit, (types.Omitted, types.NoneType)):
        ty_checker.raise_exc(limit, 'None', 'limit')

    if not isinstance(freq, (types.Omitted, types.NoneType)):
        ty_checker.raise_exc(freq, 'None', 'freq')

    def hpat_pandas_series_pct_change_impl(self, periods=1, fill_method='pad', limit=None, freq=None):
        if not (fill_method is None or fill_method in ['pad', 'ffill', 'backfill', 'bfill']):
            raise ValueError(
                "Method pct_change(). Unsupported parameter. The function uses fill_method pad (ffill) or backfill (bfill) or None.")
        local_series = self.copy()
        if fill_method is not None:
            # replacement method fillna for given method
            # =========================================
            # Example:
            # s = [1.1, 0.3, np.nan, 1, np.inf, 0, 1.1, np.nan, 2.2, np.inf, 2, 2]
            # result = [1.1, 0.3, 0.3, 1, inf, 0, 1.1, 1.1, 2.2, inf, 2, 2]
            # ==========================================
            for i in range(len(local_series._data)):
                # check each element on numpy.nan
                if numpy.isnan(local_series._data[i]):
                    if fill_method in ['pad', 'ffill']:
                        # if it first element is nan, element will be is nan
                        # if it not first element, element will be is nearest is not nan element
                        # take a step back while will not find is not nan element
                        # if before the first element you did not find one, the element will be equal nan
                        if i == 0:
                            local_series._data[i] = numpy.nan
                        else:
                            k = 1
                            while numpy.isnan(local_series._data[i - k]):
                                if i - k == 0:
                                    local_series._data[i] = numpy.nan
                                    break
                                k += 1
                            local_series._data[i] = local_series._data[i - k]
                    elif fill_method in ['backfill', 'bfill']:
                        # if it last element is nan, element will be is nan
                        # if it not last element, element will be is nearest is not nan element
                        # take a step front while will not find is not nan element
                        # if before the last element you did not find one, the element will be equal nan
                        if i == len(local_series._data)-1:
                            local_series._data[i] = numpy.nan
                        else:
                            k = 1
                            while numpy.isnan(local_series._data[i + k]):
                                if i + k == len(local_series._data) - 1:
                                    local_series._data[i] = numpy.nan
                                    break
                                k += 1
                            local_series._data[i] = local_series._data[i + k]
        rshift = local_series.shift(periods=periods, freq=freq)
        rdiv = local_series.div(rshift)
        result = rdiv._data - 1
        return pandas.Series(result)

    return hpat_pandas_series_pct_change_impl

